{"source_contract": "Crypto.compact", "source_filename": "Crypto.compact", "code": "pragma language_version >= 0.14.0;\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Left-hand side: s * B\n    const lhs: CurvePoint = ec_mul_generator(s);\n\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n  }\n}\n", "is_valid": true, "compilation_result": {"success": true, "code": "pragma language_version >= 0.14.0;\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Left-hand side: s * B\n    const lhs: CurvePoint = ec_mul_generator(s);\n\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n  }\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "", "error_messages": [], "warning_messages": [], "compilation_time_ms": 433.468, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/Crypto.compact", "timestamp": "2025-06-05T17:34:41.700980"}, "error_messages": [], "warning_messages": [], "mutation_type": "original", "instruction": "Generate a valid Compact smart contract", "expected_output": "pragma language_version >= 0.14.0;\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Left-hand side: s * B\n    const lhs: CurvePoint = ec_mul_generator(s);\n\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n  }\n}\n"}
{"source_contract": "identity.compact", "source_filename": "identity.compact", "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\nexport { CoinInfo }\nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { subject_hash }\nexport { Signature }\nexport { CredentialSubject }\nexport { SignedCredentialSubject }\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\nexport { CoinInfo }\nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { subject_hash }\nexport { Signature }\nexport { CredentialSubject }\nexport { SignedCredentialSubject }\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/identity.compact line 4, char 1:\n  failed to locate file \"../../crypto/Crypto.compact\"\n", "error_messages": ["failed to locate file \"../../crypto/Crypto.compact\""], "warning_messages": [], "compilation_time_ms": 411.545, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/identity.compact", "timestamp": "2025-06-05T17:34:42.135032"}, "error_messages": ["failed to locate file \"../../crypto/Crypto.compact\""], "warning_messages": [], "mutation_type": "original", "instruction": "Generate a valid Compact smart contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\nexport { CoinInfo }\nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { subject_hash }\nexport { Signature }\nexport { CredentialSubject }\nexport { SignedCredentialSubject }\n"}
{"source_contract": "shop.compact", "source_filename": "shop.compact", "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n  const order = get_order(id);\n  const identity = get_identity();\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  verify_signature(subject_hash(identity.subject), identity.signature);\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  receive(disclose(order.payment));\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n  const order = get_order(id);\n  const identity = get_identity();\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  verify_signature(subject_hash(identity.subject), identity.signature);\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  receive(disclose(order.payment));\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/shop.compact line 4, char 1:\n  failed to locate file \"../../crypto/Crypto.compact\"\n", "error_messages": ["failed to locate file \"../../crypto/Crypto.compact\""], "warning_messages": [], "compilation_time_ms": 472.888, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/shop.compact", "timestamp": "2025-06-05T17:34:42.546929"}, "error_messages": ["failed to locate file \"../../crypto/Crypto.compact\""], "warning_messages": [], "mutation_type": "original", "instruction": "Generate a valid Compact smart contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n  const order = get_order(id);\n  const identity = get_identity();\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  verify_signature(subject_hash(identity.subject), identity.signature);\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  receive(disclose(order.payment));\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}\n"}
{"source_contract": "registry.compact", "source_filename": "registry.compact", "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nexport { CurvePoint }\n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {\n  wallet_public_key = own_public_key();\n  signing_public_key = signing_key;\n}\n", "is_valid": true, "compilation_result": {"success": true, "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nexport { CurvePoint }\n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {\n  wallet_public_key = own_public_key();\n  signing_public_key = signing_key;\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "", "error_messages": [], "warning_messages": [], "compilation_time_ms": 492.121, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/registry.compact", "timestamp": "2025-06-05T17:34:43.020122"}, "error_messages": [], "warning_messages": [], "mutation_type": "original", "instruction": "Generate a valid Compact smart contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nexport { CurvePoint }\n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {\n  wallet_public_key = own_public_key();\n  signing_public_key = signing_key;\n}\n"}
{"source_contract": "token.compact", "source_filename": "token.compact", "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "is_valid": true, "compilation_result": {"success": true, "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "", "error_messages": [], "warning_messages": [], "compilation_time_ms": 494.81399999999996, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/token.compact", "timestamp": "2025-06-05T17:34:43.512898"}, "error_messages": [], "warning_messages": [], "mutation_type": "original", "instruction": "Generate a valid Compact smart contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n"}
{"source_contract": "battleship_west.compact", "source_filename": "battleship_west.compact", "code": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s51, ship_cell: ships.s51, ship_v: ships.v51 };\n    return get_shot_result<5>(shot_attempt, updated_ship_state.s51, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s51, ship_cell: ships.s51, ship_v: ships.v51 };\n    return get_shot_result<5>(shot_attempt, updated_ship_state.s51, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/battleship_west.compact line 13, char 1:\n  failed to locate file \"../../battleship-contract-commons/GameCommons.compact\"\n", "error_messages": ["failed to locate file \"../../battleship-contract-commons/GameCommons.compact\""], "warning_messages": [], "compilation_time_ms": 477.383, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/battleship_west.compact", "timestamp": "2025-06-05T17:34:44.008294"}, "error_messages": ["failed to locate file \"../../battleship-contract-commons/GameCommons.compact\""], "warning_messages": [], "mutation_type": "original", "instruction": "Generate a valid Compact smart contract", "expected_output": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s51, ship_cell: ships.s51, ship_v: ships.v51 };\n    return get_shot_result<5>(shot_attempt, updated_ship_state.s51, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n"}
{"source_contract": "battleship_east.compact", "source_filename": "battleship_east.compact", "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\n\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x - 1, y: cell.y},\n      Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\n\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x - 1, y: cell.y},\n      Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/battleship_east.compact line 4, char 1:\n  failed to locate file \"../../battleship-contract-commons/GameCommons.compact\"\n", "error_messages": ["failed to locate file \"../../battleship-contract-commons/GameCommons.compact\""], "warning_messages": [], "compilation_time_ms": 560.286, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/battleship_east.compact", "timestamp": "2025-06-05T17:34:44.485962"}, "error_messages": ["failed to locate file \"../../battleship-contract-commons/GameCommons.compact\""], "warning_messages": [], "mutation_type": "original", "instruction": "Generate a valid Compact smart contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\n\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x - 1, y: cell.y},\n      Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n}\n"}
{"source_contract": "GameCommons.compact", "source_filename": "GameCommons.compact", "code": "pragma language_version >= 0.13.0;\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 4) as Uint<4> }];\n    } else {\n      assert cell.x < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n\n}\n", "is_valid": true, "compilation_result": {"success": true, "code": "pragma language_version >= 0.13.0;\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 4) as Uint<4> }];\n    } else {\n      assert cell.x < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "", "error_messages": [], "warning_messages": [], "compilation_time_ms": 448.839, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/GameCommons.compact", "timestamp": "2025-06-05T17:34:45.046563"}, "error_messages": [], "warning_messages": [], "mutation_type": "original", "instruction": "Generate a valid Compact smart contract", "expected_output": "pragma language_version >= 0.13.0;\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 4) as Uint<4> }];\n    } else {\n      assert cell.x < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n\n}\n"}
{"source_contract": "token.compact", "source_filename": "token.compact", "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "is_valid": true, "compilation_result": {"success": true, "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "", "error_messages": [], "warning_messages": [], "compilation_time_ms": 478.222, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/token.compact", "timestamp": "2025-06-05T17:34:45.495861"}, "error_messages": [], "warning_messages": [], "mutation_type": "original", "instruction": "Generate a valid Compact smart contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n"}
{"source_contract": "Crypto.compact", "source_filename": "Crypto.compact_syntax_error", "code": "pragma language_version >= 0.14.0;\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R)\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Left-hand side: s * B\n    const lhs: CurvePoint = ec_mul_generator(s);\n\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n  }\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0;\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R)\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Left-hand side: s * B\n    const lhs: CurvePoint = ec_mul_generator(s);\n\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n  }\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173445.compact line 67, char 5:\n  parse error: found \"const\" looking for \";\", \"||\", \"&&\", \"==\", \"!=\", \"as\", \"+\", \"-\", \"*\", \"[\", \".\", \"?\", \"<\", \"<=\", \">=\", or \">\"\n", "error_messages": ["parse error: found \"const\" looking for \";\", \"||\", \"&&\", \"==\", \"!=\", \"as\", \"+\", \"-\", \"*\", \"[\", \".\", \"?\", \"<\", \"<=\", \">=\", or \">\""], "warning_messages": [], "compilation_time_ms": 409.306, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173445.compact", "timestamp": "2025-06-05T17:34:45.974711"}, "error_messages": ["parse error: found \"const\" looking for \";\", \"||\", \"&&\", \"==\", \"!=\", \"as\", \"+\", \"-\", \"*\", \"[\", \".\", \"?\", \"<\", \"<=\", \">=\", or \">\""], "warning_messages": [], "mutation_type": "syntax_error__introduce_missing_semicolon", "instruction": "Fix the syntax errors in this Compact contract", "expected_output": "pragma language_version >= 0.14.0;\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Left-hand side: s * B\n    const lhs: CurvePoint = ec_mul_generator(s);\n\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n  }\n}\n"}
{"source_contract": "Crypto.compact", "source_filename": "Crypto.compact_syntax_error", "code": "pragma language_version >= 0.14.0;\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  \n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Left-hand side: s * B\n    const lhs: CurvePoint = ec_mul_generator(s);\n\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n  }\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0;\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  \n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Left-hand side: s * B\n    const lhs: CurvePoint = ec_mul_generator(s);\n\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n  }\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173446.compact line 10, char 3:\n  parse error: found \"struct\" looking for a statement or \"}\"\n", "error_messages": ["parse error: found \"struct\" looking for a statement or \"}\""], "warning_messages": [], "compilation_time_ms": 405.247, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173446.compact", "timestamp": "2025-06-05T17:34:46.384408"}, "error_messages": ["parse error: found \"struct\" looking for a statement or \"}\""], "warning_messages": [], "mutation_type": "syntax_error__introduce_unmatched_braces", "instruction": "Fix the syntax errors in this Compact contract", "expected_output": "pragma language_version >= 0.14.0;\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Left-hand side: s * B\n    const lhs: CurvePoint = ec_mul_generator(s);\n\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n  }\n}\n"}
{"source_contract": "Crypto.compact", "source_filename": "Crypto.compact_syntax_error", "code": "pragma language_version >= 0.14.0;\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  function point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Left-hand side: s * B\n    const lhs: CurvePoint = ec_mul_generator(s);\n\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n  }\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0;\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  function point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Left-hand side: s * B\n    const lhs: CurvePoint = ec_mul_generator(s);\n\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n  }\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173446.compact line 6, char 3:\n  parse error: found \"function\" looking for a program element or \"}\"\n", "error_messages": ["parse error: found \"function\" looking for a program element or \"}\""], "warning_messages": [], "compilation_time_ms": 402.822, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173446.compact", "timestamp": "2025-06-05T17:34:46.789969"}, "error_messages": ["parse error: found \"function\" looking for a program element or \"}\""], "warning_messages": [], "mutation_type": "syntax_error__introduce_invalid_keywords", "instruction": "Fix the syntax errors in this Compact contract", "expected_output": "pragma language_version >= 0.14.0;\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Left-hand side: s * B\n    const lhs: CurvePoint = ec_mul_generator(s);\n\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n  }\n}\n"}
{"source_contract": "identity.compact", "source_filename": "identity.compact_syntax_error", "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\"\nexport { CoinInfo }\nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { subject_hash }\nexport { Signature }\nexport { CredentialSubject }\nexport { SignedCredentialSubject }\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\"\nexport { CoinInfo }\nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { subject_hash }\nexport { Signature }\nexport { CredentialSubject }\nexport { SignedCredentialSubject }\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173447.compact line 5, char 1:\n  parse error: found \"export\" looking for a generic argument list, an import prefix, or \";\"\n", "error_messages": ["parse error: found \"export\" looking for a generic argument list, an import prefix, or \";\""], "warning_messages": [], "compilation_time_ms": 404.144, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173447.compact", "timestamp": "2025-06-05T17:34:47.193228"}, "error_messages": ["parse error: found \"export\" looking for a generic argument list, an import prefix, or \";\""], "warning_messages": [], "mutation_type": "syntax_error__introduce_missing_semicolon", "instruction": "Fix the syntax errors in this Compact contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\nexport { CoinInfo }\nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { subject_hash }\nexport { Signature }\nexport { CredentialSubject }\nexport { SignedCredentialSubject }\n"}
{"source_contract": "identity.compact", "source_filename": "identity.compact_syntax_error", "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\nexport { CoinInfo \nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { subject_hash }\nexport { Signature }\nexport { CredentialSubject }\nexport { SignedCredentialSubject }\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\nexport { CoinInfo \nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { subject_hash }\nexport { Signature }\nexport { CredentialSubject }\nexport { SignedCredentialSubject }\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173447.compact line 6, char 1:\n  parse error: found \"export\" looking for \"}\"\n", "error_messages": ["parse error: found \"export\" looking for \"}\""], "warning_messages": [], "compilation_time_ms": 402.6, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173447.compact", "timestamp": "2025-06-05T17:34:47.597666"}, "error_messages": ["parse error: found \"export\" looking for \"}\""], "warning_messages": [], "mutation_type": "syntax_error__introduce_unmatched_braces", "instruction": "Fix the syntax errors in this Compact contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\nexport { CoinInfo }\nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { subject_hash }\nexport { Signature }\nexport { CredentialSubject }\nexport { SignedCredentialSubject }\n"}
{"source_contract": "identity.compact", "source_filename": "identity.compact_syntax_error", "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\npublic { CoinInfo }\nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { subject_hash }\nexport { Signature }\nexport { CredentialSubject }\nexport { SignedCredentialSubject }\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\npublic { CoinInfo }\nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { subject_hash }\nexport { Signature }\nexport { CredentialSubject }\nexport { SignedCredentialSubject }\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173448.compact line 5, char 1:\n  parse error: found \"public\" looking for a program element or end of file\n", "error_messages": ["parse error: found \"public\" looking for a program element or end of file"], "warning_messages": [], "compilation_time_ms": 401.538, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173448.compact", "timestamp": "2025-06-05T17:34:48.000603"}, "error_messages": ["parse error: found \"public\" looking for a program element or end of file"], "warning_messages": [], "mutation_type": "syntax_error__introduce_invalid_keywords", "instruction": "Fix the syntax errors in this Compact contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\nexport { CoinInfo }\nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { subject_hash }\nexport { Signature }\nexport { CredentialSubject }\nexport { SignedCredentialSubject }\n"}
{"source_contract": "shop.compact", "source_filename": "shop.compact_syntax_error", "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address)\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n  const order = get_order(id);\n  const identity = get_identity();\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  verify_signature(subject_hash(identity.subject), identity.signature);\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  receive(disclose(order.payment));\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address)\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n  const order = get_order(id);\n  const identity = get_identity();\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  verify_signature(subject_hash(identity.subject), identity.signature);\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  receive(disclose(order.payment));\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173448.compact line 36, char 1:\n  parse error: found \"}\" looking for \";\", \"||\", \"&&\", \"==\", \"!=\", \"as\", \"+\", \"-\", \"*\", \"[\", \".\", \"?\", \"<\", \"<=\", \">=\", or \">\"\n", "error_messages": ["parse error: found \"}\" looking for \";\", \"||\", \"&&\", \"==\", \"!=\", \"as\", \"+\", \"-\", \"*\", \"[\", \".\", \"?\", \"<\", \"<=\", \">=\", or \">\""], "warning_messages": [], "compilation_time_ms": 420.378, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173448.compact", "timestamp": "2025-06-05T17:34:48.402457"}, "error_messages": ["parse error: found \"}\" looking for \";\", \"||\", \"&&\", \"==\", \"!=\", \"as\", \"+\", \"-\", \"*\", \"[\", \".\", \"?\", \"<\", \"<=\", \">=\", or \">\""], "warning_messages": [], "mutation_type": "syntax_error__introduce_missing_semicolon", "instruction": "Fix the syntax errors in this Compact contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n  const order = get_order(id);\n  const identity = get_identity();\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  verify_signature(subject_hash(identity.subject), identity.signature);\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  receive(disclose(order.payment));\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}\n"}
{"source_contract": "shop.compact", "source_filename": "shop.compact_syntax_error", "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo \nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n  const order = get_order(id);\n  const identity = get_identity();\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  verify_signature(subject_hash(identity.subject), identity.signature);\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  receive(disclose(order.payment));\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo \nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n  const order = get_order(id);\n  const identity = get_identity();\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  verify_signature(subject_hash(identity.subject), identity.signature);\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  receive(disclose(order.payment));\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173448.compact line 7, char 1:\n  parse error: found \"export\" looking for \"}\"\n", "error_messages": ["parse error: found \"export\" looking for \"}\""], "warning_messages": [], "compilation_time_ms": 406.83599999999996, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173448.compact", "timestamp": "2025-06-05T17:34:48.823147"}, "error_messages": ["parse error: found \"export\" looking for \"}\""], "warning_messages": [], "mutation_type": "syntax_error__introduce_unmatched_braces", "instruction": "Fix the syntax errors in this Compact contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n  const order = get_order(id);\n  const identity = get_identity();\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  verify_signature(subject_hash(identity.subject), identity.signature);\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  receive(disclose(order.payment));\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}\n"}
{"source_contract": "shop.compact", "source_filename": "shop.compact_syntax_error", "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport function submit_order(id: Bytes<16>): [] {\n  const order = get_order(id);\n  const identity = get_identity();\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  verify_signature(subject_hash(identity.subject), identity.signature);\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  receive(disclose(order.payment));\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport function submit_order(id: Bytes<16>): [] {\n  const order = get_order(id);\n  const identity = get_identity();\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  verify_signature(subject_hash(identity.subject), identity.signature);\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  receive(disclose(order.payment));\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173449.compact line 39, char 8:\n  parse error: found \"function\" looking for \"module\", \"{\", a sealed modifier, \"ledger\", a pure modifier, \"circuit\", \"witness\", \"contract\", \"struct\", or \"enum\"\n", "error_messages": ["parse error: found \"function\" looking for \"module\", \"{\", a sealed modifier, \"ledger\", a pure modifier, \"circuit\", \"witness\", \"contract\", \"struct\", or \"enum\""], "warning_messages": [], "compilation_time_ms": 407.968, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173449.compact", "timestamp": "2025-06-05T17:34:49.230275"}, "error_messages": ["parse error: found \"function\" looking for \"module\", \"{\", a sealed modifier, \"ledger\", a pure modifier, \"circuit\", \"witness\", \"contract\", \"struct\", or \"enum\""], "warning_messages": [], "mutation_type": "syntax_error__introduce_invalid_keywords", "instruction": "Fix the syntax errors in this Compact contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n  const order = get_order(id);\n  const identity = get_identity();\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  verify_signature(subject_hash(identity.subject), identity.signature);\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  receive(disclose(order.payment));\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}\n"}
{"source_contract": "registry.compact", "source_filename": "registry.compact_syntax_error", "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary\nexport { CurvePoint }\n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {\n  wallet_public_key = own_public_key();\n  signing_public_key = signing_key;\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary\nexport { CurvePoint }\n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {\n  wallet_public_key = own_public_key();\n  signing_public_key = signing_key;\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173449.compact line 4, char 1:\n  parse error: found \"export\" looking for a generic argument list, an import prefix, or \";\"\n", "error_messages": ["parse error: found \"export\" looking for a generic argument list, an import prefix, or \";\""], "warning_messages": [], "compilation_time_ms": 409.723, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173449.compact", "timestamp": "2025-06-05T17:34:49.638568"}, "error_messages": ["parse error: found \"export\" looking for a generic argument list, an import prefix, or \";\""], "warning_messages": [], "mutation_type": "syntax_error__introduce_missing_semicolon", "instruction": "Fix the syntax errors in this Compact contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nexport { CurvePoint }\n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {\n  wallet_public_key = own_public_key();\n  signing_public_key = signing_key;\n}\n"}
{"source_contract": "registry.compact", "source_filename": "registry.compact_syntax_error", "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nexport { CurvePoint \n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {\n  wallet_public_key = own_public_key();\n  signing_public_key = signing_key;\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nexport { CurvePoint \n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {\n  wallet_public_key = own_public_key();\n  signing_public_key = signing_key;\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173450.compact line 6, char 1:\n  parse error: found \"export\" looking for \"}\"\n", "error_messages": ["parse error: found \"export\" looking for \"}\""], "warning_messages": [], "compilation_time_ms": 404.921, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173450.compact", "timestamp": "2025-06-05T17:34:50.048586"}, "error_messages": ["parse error: found \"export\" looking for \"}\""], "warning_messages": [], "mutation_type": "syntax_error__introduce_unmatched_braces", "instruction": "Fix the syntax errors in this Compact contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nexport { CurvePoint }\n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {\n  wallet_public_key = own_public_key();\n  signing_public_key = signing_key;\n}\n"}
{"source_contract": "registry.compact", "source_filename": "registry.compact_syntax_error", "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nexport { CurvePoint }\n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport function register(signing_key: CurvePoint): [] {\n  wallet_public_key = own_public_key();\n  signing_public_key = signing_key;\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nexport { CurvePoint }\n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport function register(signing_key: CurvePoint): [] {\n  wallet_public_key = own_public_key();\n  signing_public_key = signing_key;\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173450.compact line 9, char 8:\n  parse error: found \"function\" looking for \"module\", \"{\", a sealed modifier, \"ledger\", a pure modifier, \"circuit\", \"witness\", \"contract\", \"struct\", or \"enum\"\n", "error_messages": ["parse error: found \"function\" looking for \"module\", \"{\", a sealed modifier, \"ledger\", a pure modifier, \"circuit\", \"witness\", \"contract\", \"struct\", or \"enum\""], "warning_messages": [], "compilation_time_ms": 401.293, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173450.compact", "timestamp": "2025-06-05T17:34:50.453782"}, "error_messages": ["parse error: found \"function\" looking for \"module\", \"{\", a sealed modifier, \"ledger\", a pure modifier, \"circuit\", \"witness\", \"contract\", \"struct\", or \"enum\""], "warning_messages": [], "mutation_type": "syntax_error__introduce_invalid_keywords", "instruction": "Fix the syntax errors in this Compact contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nexport { CurvePoint }\n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {\n  wallet_public_key = own_public_key();\n  signing_public_key = signing_key;\n}\n"}
{"source_contract": "token.compact", "source_filename": "token.compact_syntax_error", "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1)\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1)\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173450.compact line 17, char 3:\n  parse error: found \"const\" looking for \";\", \",\", \"||\", \"&&\", \"==\", \"!=\", \"as\", \"+\", \"-\", \"*\", \"[\", \".\", \"=\", \"+=\", \"-=\", \"<\", \"<=\", \">=\", \">\", or \"?\"\n", "error_messages": ["parse error: found \"const\" looking for \";\", \",\", \"||\", \"&&\", \"==\", \"!=\", \"as\", \"+\", \"-\", \"*\", \"[\", \".\", \"=\", \"+=\", \"-=\", \"<\", \"<=\", \">=\", \">\", or \"?\""], "warning_messages": [], "compilation_time_ms": 460.71000000000004, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173450.compact", "timestamp": "2025-06-05T17:34:50.855403"}, "error_messages": ["parse error: found \"const\" looking for \";\", \",\", \"||\", \"&&\", \"==\", \"!=\", \"as\", \"+\", \"-\", \"*\", \"[\", \".\", \"=\", \"+=\", \"-=\", \"<\", \"<=\", \">=\", \">\", or \"?\""], "warning_messages": [], "mutation_type": "syntax_error__introduce_missing_semicolon", "instruction": "Fix the syntax errors in this Compact contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n"}
{"source_contract": "token.compact", "source_filename": "token.compact_syntax_error", "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo ;\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo ;\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173451.compact line 5, char 19:\n  parse error: found \";\" looking for \"}\"\n", "error_messages": ["parse error: found \";\" looking for \"}\""], "warning_messages": [], "compilation_time_ms": 423.74600000000004, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173451.compact", "timestamp": "2025-06-05T17:34:51.316433"}, "error_messages": ["parse error: found \";\" looking for \"}\""], "warning_messages": [], "mutation_type": "syntax_error__introduce_unmatched_braces", "instruction": "Fix the syntax errors in this Compact contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n"}
{"source_contract": "token.compact", "source_filename": "token.compact_syntax_error", "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport function mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport function mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173451.compact line 15, char 8:\n  parse error: found \"function\" looking for \"module\", \"{\", a sealed modifier, \"ledger\", a pure modifier, \"circuit\", \"witness\", \"contract\", \"struct\", or \"enum\"\n", "error_messages": ["parse error: found \"function\" looking for \"module\", \"{\", a sealed modifier, \"ledger\", a pure modifier, \"circuit\", \"witness\", \"contract\", \"struct\", or \"enum\""], "warning_messages": [], "compilation_time_ms": 407.566, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173451.compact", "timestamp": "2025-06-05T17:34:51.740481"}, "error_messages": ["parse error: found \"function\" looking for \"module\", \"{\", a sealed modifier, \"ledger\", a pure modifier, \"circuit\", \"witness\", \"contract\", \"struct\", or \"enum\""], "warning_messages": [], "mutation_type": "syntax_error__introduce_invalid_keywords", "instruction": "Fix the syntax errors in this Compact contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n"}
{"source_contract": "battleship_west.compact", "source_filename": "battleship_west.compact_syntax_error", "code": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\"\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s51, ship_cell: ships.s51, ship_v: ships.v51 };\n    return get_shot_result<5>(shot_attempt, updated_ship_state.s51, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\"\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s51, ship_cell: ships.s51, ship_v: ships.v51 };\n    return get_shot_result<5>(shot_attempt, updated_ship_state.s51, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173452.compact line 178, char 3:\n  parse error: found \"assert_valid_coordinate\" looking for \";\"\n", "error_messages": ["parse error: found \"assert_valid_coordinate\" looking for \";\""], "warning_messages": [], "compilation_time_ms": 455.04299999999995, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173452.compact", "timestamp": "2025-06-05T17:34:52.148415"}, "error_messages": ["parse error: found \"assert_valid_coordinate\" looking for \";\""], "warning_messages": [], "mutation_type": "syntax_error__introduce_missing_semicolon", "instruction": "Fix the syntax errors in this Compact contract", "expected_output": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s51, ship_cell: ships.s51, ship_v: ships.v51 };\n    return get_shot_result<5>(shot_attempt, updated_ship_state.s51, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n"}
{"source_contract": "battleship_west.compact", "source_filename": "battleship_west.compact_syntax_error", "code": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe \nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s51, ship_cell: ships.s51, ship_v: ships.v51 };\n    return get_shot_result<5>(shot_attempt, updated_ship_state.s51, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe \nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s51, ship_cell: ships.s51, ship_v: ships.v51 };\n    return get_shot_result<5>(shot_attempt, updated_ship_state.s51, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173452.compact line 16, char 1:\n  parse error: found \"export\" looking for \"}\"\n", "error_messages": ["parse error: found \"export\" looking for \"}\""], "warning_messages": [], "compilation_time_ms": 403.565, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173452.compact", "timestamp": "2025-06-05T17:34:52.603791"}, "error_messages": ["parse error: found \"export\" looking for \"}\""], "warning_messages": [], "mutation_type": "syntax_error__introduce_unmatched_braces", "instruction": "Fix the syntax errors in this Compact contract", "expected_output": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s51, ship_cell: ships.s51, ship_v: ships.v51 };\n    return get_shot_result<5>(shot_attempt, updated_ship_state.s51, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n"}
{"source_contract": "battleship_west.compact", "source_filename": "battleship_west.compact_syntax_error", "code": "// The main functions are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s51, ship_cell: ships.s51, ship_v: ships.v51 };\n    return get_shot_result<5>(shot_attempt, updated_ship_state.s51, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "// The main functions are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s51, ship_cell: ships.s51, ship_v: ships.v51 };\n    return get_shot_result<5>(shot_attempt, updated_ship_state.s51, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173453.compact line 13, char 1:\n  failed to locate file \"../../battleship-contract-commons/GameCommons.compact\"\n", "error_messages": ["failed to locate file \"../../battleship-contract-commons/GameCommons.compact\""], "warning_messages": [], "compilation_time_ms": 483.35, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173453.compact", "timestamp": "2025-06-05T17:34:53.007625"}, "error_messages": ["failed to locate file \"../../battleship-contract-commons/GameCommons.compact\""], "warning_messages": [], "mutation_type": "syntax_error__introduce_invalid_keywords", "instruction": "Fix the syntax errors in this Compact contract", "expected_output": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s51, ship_cell: ships.s51, ship_v: ships.v51 };\n    return get_shot_result<5>(shot_attempt, updated_ship_state.s51, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n"}
{"source_contract": "battleship_east.compact", "source_filename": "battleship_east.compact_syntax_error", "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords)\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\n\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x - 1, y: cell.y},\n      Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords)\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\n\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x - 1, y: cell.y},\n      Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173453.compact line 351, char 3:\n  parse error: found \"}\" looking for \";\", \",\", \"||\", \"&&\", \"==\", \"!=\", \"as\", \"+\", \"-\", \"*\", \"[\", \".\", \"=\", \"+=\", \"-=\", \"?\", \"<\", \"<=\", \">=\", or \">\"\n", "error_messages": ["parse error: found \"}\" looking for \";\", \",\", \"||\", \"&&\", \"==\", \"!=\", \"as\", \"+\", \"-\", \"*\", \"[\", \".\", \"=\", \"+=\", \"-=\", \"?\", \"<\", \"<=\", \">=\", or \">\""], "warning_messages": [], "compilation_time_ms": 724.957, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173453.compact", "timestamp": "2025-06-05T17:34:53.491370"}, "error_messages": ["parse error: found \"}\" looking for \";\", \",\", \"||\", \"&&\", \"==\", \"!=\", \"as\", \"+\", \"-\", \"*\", \"[\", \".\", \"=\", \"+=\", \"-=\", \"?\", \"<\", \"<=\", \">=\", or \">\""], "warning_messages": [], "mutation_type": "syntax_error__introduce_missing_semicolon", "instruction": "Fix the syntax errors in this Compact contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\n\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x - 1, y: cell.y},\n      Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n}\n"}
{"source_contract": "battleship_east.compact", "source_filename": "battleship_east.compact_syntax_error", "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe \nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\n\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x - 1, y: cell.y},\n      Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe \nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\n\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x - 1, y: cell.y},\n      Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173454.compact line 7, char 1:\n  parse error: found \"export\" looking for \"}\"\n", "error_messages": ["parse error: found \"export\" looking for \"}\""], "warning_messages": [], "compilation_time_ms": 401.929, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173454.compact", "timestamp": "2025-06-05T17:34:54.216636"}, "error_messages": ["parse error: found \"export\" looking for \"}\""], "warning_messages": [], "mutation_type": "syntax_error__introduce_unmatched_braces", "instruction": "Fix the syntax errors in this Compact contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\n\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x - 1, y: cell.y},\n      Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n}\n"}
{"source_contract": "battleship_east.compact", "source_filename": "battleship_east.compact_syntax_error", "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport function join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\n\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x - 1, y: cell.y},\n      Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport function join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\n\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x - 1, y: cell.y},\n      Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173454.compact line 78, char 8:\n  parse error: found \"function\" looking for \"module\", \"{\", a sealed modifier, \"ledger\", a pure modifier, \"circuit\", \"witness\", \"contract\", \"struct\", or \"enum\"\n", "error_messages": ["parse error: found \"function\" looking for \"module\", \"{\", a sealed modifier, \"ledger\", a pure modifier, \"circuit\", \"witness\", \"contract\", \"struct\", or \"enum\""], "warning_messages": [], "compilation_time_ms": 418.281, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173454.compact", "timestamp": "2025-06-05T17:34:54.618852"}, "error_messages": ["parse error: found \"function\" looking for \"module\", \"{\", a sealed modifier, \"ledger\", a pure modifier, \"circuit\", \"witness\", \"contract\", \"struct\", or \"enum\""], "warning_messages": [], "mutation_type": "syntax_error__introduce_invalid_keywords", "instruction": "Fix the syntax errors in this Compact contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\n\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x - 1, y: cell.y},\n      Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n}\n"}
{"source_contract": "GameCommons.compact", "source_filename": "GameCommons.compact_syntax_error", "code": "pragma language_version >= 0.13.0;\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 4) as Uint<4> }];\n    } else {\n      assert cell.x < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 4) as Uint<4> }];\n    } else {\n      assert cell.x < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173455.compact line 20, char 5:\n  parse error: found \"ship_def\" looking for \";\" or \"}\"\n", "error_messages": ["parse error: found \"ship_def\" looking for \";\" or \"}\""], "warning_messages": [], "compilation_time_ms": 405.012, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173455.compact", "timestamp": "2025-06-05T17:34:55.037486"}, "error_messages": ["parse error: found \"ship_def\" looking for \";\" or \"}\""], "warning_messages": [], "mutation_type": "syntax_error__introduce_missing_semicolon", "instruction": "Fix the syntax errors in this Compact contract", "expected_output": "pragma language_version >= 0.13.0;\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 4) as Uint<4> }];\n    } else {\n      assert cell.x < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n\n}\n"}
{"source_contract": "GameCommons.compact", "source_filename": "GameCommons.compact_syntax_error", "code": "pragma language_version >= 0.13.0;\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins \n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 4) as Uint<4> }];\n    } else {\n      assert cell.x < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins \n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 4) as Uint<4> }];\n    } else {\n      assert cell.x < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173455.compact line 7, char 3:\n  parse error: found \"export\" looking for \",\" or \"}\"\n", "error_messages": ["parse error: found \"export\" looking for \",\" or \"}\""], "warning_messages": [], "compilation_time_ms": 402.698, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173455.compact", "timestamp": "2025-06-05T17:34:55.442788"}, "error_messages": ["parse error: found \"export\" looking for \",\" or \"}\""], "warning_messages": [], "mutation_type": "syntax_error__introduce_unmatched_braces", "instruction": "Fix the syntax errors in this Compact contract", "expected_output": "pragma language_version >= 0.13.0;\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 4) as Uint<4> }];\n    } else {\n      assert cell.x < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n\n}\n"}
{"source_contract": "GameCommons.compact", "source_filename": "GameCommons.compact_syntax_error", "code": "pragma language_version >= 0.13.0;\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure function unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 4) as Uint<4> }];\n    } else {\n      assert cell.x < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure function unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 4) as Uint<4> }];\n    } else {\n      assert cell.x < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173455.compact line 28, char 15:\n  parse error: found \"function\" looking for \"circuit\"\n", "error_messages": ["parse error: found \"function\" looking for \"circuit\""], "warning_messages": [], "compilation_time_ms": 409.501, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173455.compact", "timestamp": "2025-06-05T17:34:55.845776"}, "error_messages": ["parse error: found \"function\" looking for \"circuit\""], "warning_messages": [], "mutation_type": "syntax_error__introduce_invalid_keywords", "instruction": "Fix the syntax errors in this Compact contract", "expected_output": "pragma language_version >= 0.13.0;\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 4) as Uint<4> }];\n    } else {\n      assert cell.x < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n\n}\n"}
{"source_contract": "token.compact", "source_filename": "token.compact_syntax_error", "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo }\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "is_valid": true, "compilation_result": {"success": true, "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo }\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "", "error_messages": [], "warning_messages": [], "compilation_time_ms": 484.485, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173456.compact", "timestamp": "2025-06-05T17:34:56.255643"}, "error_messages": [], "warning_messages": [], "mutation_type": "syntax_error__introduce_missing_semicolon", "instruction": "Fix the syntax errors in this Compact contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n"}
{"source_contract": "token.compact", "source_filename": "token.compact_syntax_error", "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo ;\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo ;\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173456.compact line 5, char 19:\n  parse error: found \";\" looking for \"}\"\n", "error_messages": ["parse error: found \";\" looking for \"}\""], "warning_messages": [], "compilation_time_ms": 404.411, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173456.compact", "timestamp": "2025-06-05T17:34:56.740704"}, "error_messages": ["parse error: found \";\" looking for \"}\""], "warning_messages": [], "mutation_type": "syntax_error__introduce_unmatched_braces", "instruction": "Fix the syntax errors in this Compact contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n"}
{"source_contract": "token.compact", "source_filename": "token.compact_syntax_error", "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport function mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport function mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173457.compact line 15, char 8:\n  parse error: found \"function\" looking for \"module\", \"{\", a sealed modifier, \"ledger\", a pure modifier, \"circuit\", \"witness\", \"contract\", \"struct\", or \"enum\"\n", "error_messages": ["parse error: found \"function\" looking for \"module\", \"{\", a sealed modifier, \"ledger\", a pure modifier, \"circuit\", \"witness\", \"contract\", \"struct\", or \"enum\""], "warning_messages": [], "compilation_time_ms": 408.54, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173457.compact", "timestamp": "2025-06-05T17:34:57.145405"}, "error_messages": ["parse error: found \"function\" looking for \"module\", \"{\", a sealed modifier, \"ledger\", a pure modifier, \"circuit\", \"witness\", \"contract\", \"struct\", or \"enum\""], "warning_messages": [], "mutation_type": "syntax_error__introduce_invalid_keywords", "instruction": "Fix the syntax errors in this Compact contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n"}
{"source_contract": "Crypto.compact", "source_filename": "Crypto.compact_type_error", "code": "pragma language_version >= 0.14.0;\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: String; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Left-hand side: s * B\n    const lhs: CurvePoint = ec_mul_generator(s);\n\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n  }\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0;\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: String; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Left-hand side: s * B\n    const lhs: CurvePoint = ec_mul_generator(s);\n\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n  }\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173457.compact line 34, char 24:\n  unbound identifier String\n", "error_messages": [], "warning_messages": [], "compilation_time_ms": 427.183, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173457.compact", "timestamp": "2025-06-05T17:34:57.554280"}, "error_messages": [], "warning_messages": [], "mutation_type": "type_error__introduce_type_mismatch", "instruction": "Fix the type errors in this Compact contract", "expected_output": "pragma language_version >= 0.14.0;\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Left-hand side: s * B\n    const lhs: CurvePoint = ec_mul_generator(s);\n\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n  }\n}\n"}
{"source_contract": "Crypto.compact", "source_filename": "Crypto.compact_type_error", "code": "pragma language_version >= undefined_variable + 0.14.0;\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Left-hand side: s * B\n    const lhs: CurvePoint = ec_mul_generator(s);\n\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n  }\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= undefined_variable + 0.14.0;\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Left-hand side: s * B\n    const lhs: CurvePoint = ec_mul_generator(s);\n\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n  }\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173457.compact line 1, char 28:\n  parse error: found \"undefined_variable\" looking for a version atom\n", "error_messages": ["parse error: found \"undefined_variable\" looking for a version atom"], "warning_messages": [], "compilation_time_ms": 403.971, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173457.compact", "timestamp": "2025-06-05T17:34:57.981759"}, "error_messages": ["parse error: found \"undefined_variable\" looking for a version atom"], "warning_messages": [], "mutation_type": "type_error__introduce_undefined_variable", "instruction": "Fix the type errors in this Compact contract", "expected_output": "pragma language_version >= 0.14.0;\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Left-hand side: s * B\n    const lhs: CurvePoint = ec_mul_generator(s);\n\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n  }\n}\n"}
{"source_contract": "identity.compact", "source_filename": "identity.compact_type_error", "code": "pragma language_version >= undefined_variable + 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\nexport { CoinInfo }\nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { subject_hash }\nexport { Signature }\nexport { CredentialSubject }\nexport { SignedCredentialSubject }\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= undefined_variable + 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\nexport { CoinInfo }\nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { subject_hash }\nexport { Signature }\nexport { CredentialSubject }\nexport { SignedCredentialSubject }\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173458.compact line 1, char 28:\n  parse error: found \"undefined_variable\" looking for a version atom\n", "error_messages": ["parse error: found \"undefined_variable\" looking for a version atom"], "warning_messages": [], "compilation_time_ms": 418.491, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173458.compact", "timestamp": "2025-06-05T17:34:58.386282"}, "error_messages": ["parse error: found \"undefined_variable\" looking for a version atom"], "warning_messages": [], "mutation_type": "type_error__introduce_undefined_variable", "instruction": "Fix the type errors in this Compact contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\nexport { CoinInfo }\nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { subject_hash }\nexport { Signature }\nexport { CredentialSubject }\nexport { SignedCredentialSubject }\n"}
{"source_contract": "shop.compact", "source_filename": "shop.compact_type_error", "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: String; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n  const order = get_order(id);\n  const identity = get_identity();\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  verify_signature(subject_hash(identity.subject), identity.signature);\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  receive(disclose(order.payment));\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: String; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n  const order = get_order(id);\n  const identity = get_identity();\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  verify_signature(subject_hash(identity.subject), identity.signature);\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  receive(disclose(order.payment));\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173458.compact line 4, char 1:\n  failed to locate file \"../../crypto/Crypto.compact\"\n", "error_messages": ["failed to locate file \"../../crypto/Crypto.compact\""], "warning_messages": [], "compilation_time_ms": 428.851, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173458.compact", "timestamp": "2025-06-05T17:34:58.805101"}, "error_messages": ["failed to locate file \"../../crypto/Crypto.compact\""], "warning_messages": [], "mutation_type": "type_error__introduce_type_mismatch", "instruction": "Fix the type errors in this Compact contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n  const order = get_order(id);\n  const identity = get_identity();\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  verify_signature(subject_hash(identity.subject), identity.signature);\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  receive(disclose(order.payment));\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}\n"}
{"source_contract": "shop.compact", "source_filename": "shop.compact_type_error", "code": "pragma language_version >= undefined_variable + 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n  const order = get_order(id);\n  const identity = get_identity();\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  verify_signature(subject_hash(identity.subject), identity.signature);\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  receive(disclose(order.payment));\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= undefined_variable + 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n  const order = get_order(id);\n  const identity = get_identity();\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  verify_signature(subject_hash(identity.subject), identity.signature);\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  receive(disclose(order.payment));\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173459.compact line 1, char 28:\n  parse error: found \"undefined_variable\" looking for a version atom\n", "error_messages": ["parse error: found \"undefined_variable\" looking for a version atom"], "warning_messages": [], "compilation_time_ms": 402.657, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173459.compact", "timestamp": "2025-06-05T17:34:59.234246"}, "error_messages": ["parse error: found \"undefined_variable\" looking for a version atom"], "warning_messages": [], "mutation_type": "type_error__introduce_undefined_variable", "instruction": "Fix the type errors in this Compact contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n  const order = get_order(id);\n  const identity = get_identity();\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  verify_signature(subject_hash(identity.subject), identity.signature);\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  receive(disclose(order.payment));\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}\n"}
{"source_contract": "shop.compact", "source_filename": "shop.compact_type_error", "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(extra_arg): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n  const order = get_order(id);\n  const identity = get_identity();\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  verify_signature(subject_hash(identity.subject), identity.signature);\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  receive(disclose(order.payment));\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(extra_arg): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n  const order = get_order(id);\n  const identity = get_identity();\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  verify_signature(subject_hash(identity.subject), identity.signature);\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  receive(disclose(order.payment));\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173459.compact line 23, char 31:\n  parse error: found \")\" looking for \":\"\n", "error_messages": ["parse error: found \")\" looking for \":\""], "warning_messages": [], "compilation_time_ms": 430.694, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173459.compact", "timestamp": "2025-06-05T17:34:59.637264"}, "error_messages": ["parse error: found \")\" looking for \":\""], "warning_messages": [], "mutation_type": "type_error__introduce_wrong_function_args", "instruction": "Fix the type errors in this Compact contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n  const order = get_order(id);\n  const identity = get_identity();\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  verify_signature(subject_hash(identity.subject), identity.signature);\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  receive(disclose(order.payment));\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}\n"}
{"source_contract": "registry.compact", "source_filename": "registry.compact_type_error", "code": "pragma language_version >= undefined_variable + 0.14.0;\n\nimport CompactStandardLibrary;\nexport { CurvePoint }\n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {\n  wallet_public_key = own_public_key();\n  signing_public_key = signing_key;\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= undefined_variable + 0.14.0;\n\nimport CompactStandardLibrary;\nexport { CurvePoint }\n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {\n  wallet_public_key = own_public_key();\n  signing_public_key = signing_key;\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173500.compact line 1, char 28:\n  parse error: found \"undefined_variable\" looking for a version atom\n", "error_messages": ["parse error: found \"undefined_variable\" looking for a version atom"], "warning_messages": [], "compilation_time_ms": 410.25800000000004, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173500.compact", "timestamp": "2025-06-05T17:35:00.068456"}, "error_messages": ["parse error: found \"undefined_variable\" looking for a version atom"], "warning_messages": [], "mutation_type": "type_error__introduce_undefined_variable", "instruction": "Fix the type errors in this Compact contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nexport { CurvePoint }\n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {\n  wallet_public_key = own_public_key();\n  signing_public_key = signing_key;\n}\n"}
{"source_contract": "registry.compact", "source_filename": "registry.compact_type_error", "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nexport { CurvePoint }\n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {\n  wallet_public_key = own_public_key(extra_arg);\n  signing_public_key = signing_key;\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nexport { CurvePoint }\n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {\n  wallet_public_key = own_public_key(extra_arg);\n  signing_public_key = signing_key;\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173500.compact line 10, char 38:\n  unbound identifier extra_arg\n", "error_messages": [], "warning_messages": [], "compilation_time_ms": 416.979, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173500.compact", "timestamp": "2025-06-05T17:35:00.479030"}, "error_messages": [], "warning_messages": [], "mutation_type": "type_error__introduce_wrong_function_args", "instruction": "Fix the type errors in this Compact contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nexport { CurvePoint }\n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {\n  wallet_public_key = own_public_key();\n  signing_public_key = signing_key;\n}\n"}
{"source_contract": "token.compact", "source_filename": "token.compact_type_error", "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: String;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: String;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173500.compact line 9, char 20:\n  unbound identifier String\n", "error_messages": [], "warning_messages": [], "compilation_time_ms": 442.83099999999996, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173500.compact", "timestamp": "2025-06-05T17:35:00.896293"}, "error_messages": [], "warning_messages": [], "mutation_type": "type_error__introduce_type_mismatch", "instruction": "Fix the type errors in this Compact contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n"}
{"source_contract": "token.compact", "source_filename": "token.compact_type_error", "code": "pragma language_version >= undefined_variable + 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= undefined_variable + 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173501.compact line 1, char 28:\n  parse error: found \"undefined_variable\" looking for a version atom\n", "error_messages": ["parse error: found \"undefined_variable\" looking for a version atom"], "warning_messages": [], "compilation_time_ms": 433.424, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173501.compact", "timestamp": "2025-06-05T17:35:01.339467"}, "error_messages": ["parse error: found \"undefined_variable\" looking for a version atom"], "warning_messages": [], "mutation_type": "type_error__introduce_undefined_variable", "instruction": "Fix the type errors in this Compact contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n"}
{"source_contract": "token.compact", "source_filename": "token.compact_type_error", "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(extra_arg): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(extra_arg): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173501.compact line 15, char 30:\n  parse error: found \")\" looking for \":\"\n", "error_messages": ["parse error: found \")\" looking for \":\""], "warning_messages": [], "compilation_time_ms": 410.155, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173501.compact", "timestamp": "2025-06-05T17:35:01.773225"}, "error_messages": ["parse error: found \")\" looking for \":\""], "warning_messages": [], "mutation_type": "type_error__introduce_wrong_function_args", "instruction": "Fix the type errors in this Compact contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n"}
{"source_contract": "battleship_west.compact", "source_filename": "battleship_west.compact_type_error", "code": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Uint<32>;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s51, ship_cell: ships.s51, ship_v: ships.v51 };\n    return get_shot_result<5>(shot_attempt, updated_ship_state.s51, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Uint<32>;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s51, ship_cell: ships.s51, ship_v: ships.v51 };\n    return get_shot_result<5>(shot_attempt, updated_ship_state.s51, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173502.compact line 13, char 1:\n  failed to locate file \"../../battleship-contract-commons/GameCommons.compact\"\n", "error_messages": ["failed to locate file \"../../battleship-contract-commons/GameCommons.compact\""], "warning_messages": [], "compilation_time_ms": 488.385, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173502.compact", "timestamp": "2025-06-05T17:35:02.183672"}, "error_messages": ["failed to locate file \"../../battleship-contract-commons/GameCommons.compact\""], "warning_messages": [], "mutation_type": "type_error__introduce_type_mismatch", "instruction": "Fix the type errors in this Compact contract", "expected_output": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s51, ship_cell: ships.s51, ship_v: ships.v51 };\n    return get_shot_result<5>(shot_attempt, updated_ship_state.s51, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n"}
{"source_contract": "battleship_west.compact", "source_filename": "battleship_west.compact_type_error", "code": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= undefined_variable + 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s51, ship_cell: ships.s51, ship_v: ships.v51 };\n    return get_shot_result<5>(shot_attempt, updated_ship_state.s51, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= undefined_variable + 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s51, ship_cell: ships.s51, ship_v: ships.v51 };\n    return get_shot_result<5>(shot_attempt, updated_ship_state.s51, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173502.compact line 10, char 28:\n  parse error: found \"undefined_variable\" looking for a version atom\n", "error_messages": ["parse error: found \"undefined_variable\" looking for a version atom"], "warning_messages": [], "compilation_time_ms": 409.293, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173502.compact", "timestamp": "2025-06-05T17:35:02.672399"}, "error_messages": ["parse error: found \"undefined_variable\" looking for a version atom"], "warning_messages": [], "mutation_type": "type_error__introduce_undefined_variable", "instruction": "Fix the type errors in this Compact contract", "expected_output": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s51, ship_cell: ships.s51, ship_v: ships.v51 };\n    return get_shot_result<5>(shot_attempt, updated_ship_state.s51, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n"}
{"source_contract": "battleship_west.compact", "source_filename": "battleship_west.compact_type_error", "code": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(extra_arg): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s51, ship_cell: ships.s51, ship_v: ships.v51 };\n    return get_shot_result<5>(shot_attempt, updated_ship_state.s51, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(extra_arg): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s51, ship_cell: ships.s51, ship_v: ships.v51 };\n    return get_shot_result<5>(shot_attempt, updated_ship_state.s51, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173503.compact line 46, char 35:\n  parse error: found \")\" looking for \":\"\n", "error_messages": ["parse error: found \")\" looking for \":\""], "warning_messages": [], "compilation_time_ms": 406.992, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173503.compact", "timestamp": "2025-06-05T17:35:03.082113"}, "error_messages": ["parse error: found \")\" looking for \":\""], "warning_messages": [], "mutation_type": "type_error__introduce_wrong_function_args", "instruction": "Fix the type errors in this Compact contract", "expected_output": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s51, ship_cell: ships.s51, ship_v: ships.v51 };\n    return get_shot_result<5>(shot_attempt, updated_ship_state.s51, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n"}
{"source_contract": "battleship_east.compact", "source_filename": "battleship_east.compact_type_error", "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Uint<32>;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\n\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x - 1, y: cell.y},\n      Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Uint<32>;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\n\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x - 1, y: cell.y},\n      Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173503.compact line 4, char 1:\n  failed to locate file \"../../battleship-contract-commons/GameCommons.compact\"\n", "error_messages": ["failed to locate file \"../../battleship-contract-commons/GameCommons.compact\""], "warning_messages": [], "compilation_time_ms": 570.567, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173503.compact", "timestamp": "2025-06-05T17:35:03.489468"}, "error_messages": ["failed to locate file \"../../battleship-contract-commons/GameCommons.compact\""], "warning_messages": [], "mutation_type": "type_error__introduce_type_mismatch", "instruction": "Fix the type errors in this Compact contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\n\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x - 1, y: cell.y},\n      Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n}\n"}
{"source_contract": "battleship_east.compact", "source_filename": "battleship_east.compact_type_error", "code": "pragma language_version >= undefined_variable + 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\n\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x - 1, y: cell.y},\n      Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= undefined_variable + 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\n\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x - 1, y: cell.y},\n      Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173504.compact line 1, char 28:\n  parse error: found \"undefined_variable\" looking for a version atom\n", "error_messages": ["parse error: found \"undefined_variable\" looking for a version atom"], "warning_messages": [], "compilation_time_ms": 403.046, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173504.compact", "timestamp": "2025-06-05T17:35:04.060374"}, "error_messages": ["parse error: found \"undefined_variable\" looking for a version atom"], "warning_messages": [], "mutation_type": "type_error__introduce_undefined_variable", "instruction": "Fix the type errors in this Compact contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\n\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x - 1, y: cell.y},\n      Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n}\n"}
{"source_contract": "battleship_east.compact", "source_filename": "battleship_east.compact_type_error", "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(extra_arg): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\n\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x - 1, y: cell.y},\n      Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(extra_arg): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\n\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x - 1, y: cell.y},\n      Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173504.compact line 29, char 35:\n  parse error: found \")\" looking for \":\"\n", "error_messages": ["parse error: found \")\" looking for \":\""], "warning_messages": [], "compilation_time_ms": 405.95, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173504.compact", "timestamp": "2025-06-05T17:35:04.463776"}, "error_messages": ["parse error: found \")\" looking for \":\""], "warning_messages": [], "mutation_type": "type_error__introduce_wrong_function_args", "instruction": "Fix the type errors in this Compact contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\n\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x - 1, y: cell.y},\n      Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n}\n"}
{"source_contract": "GameCommons.compact", "source_filename": "GameCommons.compact_type_error", "code": "pragma language_version >= 0.13.0;\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Uint<32>;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 4) as Uint<4> }];\n    } else {\n      assert cell.x < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Uint<32>;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 4) as Uint<4> }];\n    } else {\n      assert cell.x < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173504.compact line 29, char 12:\n  mismatch between actual type Boolean and declared type Uint<32> for field ship_v of struct ShipDef<ship: Enum<SHIP, s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown>, ship_cell: struct Coord<x: Uint<4>, y: Uint<4>>, ship_v: Uint<32>>\n", "error_messages": [], "warning_messages": [], "compilation_time_ms": 446.457, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173504.compact", "timestamp": "2025-06-05T17:35:04.870030"}, "error_messages": [], "warning_messages": [], "mutation_type": "type_error__introduce_type_mismatch", "instruction": "Fix the type errors in this Compact contract", "expected_output": "pragma language_version >= 0.13.0;\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 4) as Uint<4> }];\n    } else {\n      assert cell.x < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n\n}\n"}
{"source_contract": "GameCommons.compact", "source_filename": "GameCommons.compact_type_error", "code": "pragma language_version >= undefined_variable + 0.13.0;\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 4) as Uint<4> }];\n    } else {\n      assert cell.x < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= undefined_variable + 0.13.0;\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 4) as Uint<4> }];\n    } else {\n      assert cell.x < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173505.compact line 1, char 28:\n  parse error: found \"undefined_variable\" looking for a version atom\n", "error_messages": ["parse error: found \"undefined_variable\" looking for a version atom"], "warning_messages": [], "compilation_time_ms": 410.69, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173505.compact", "timestamp": "2025-06-05T17:35:05.316791"}, "error_messages": ["parse error: found \"undefined_variable\" looking for a version atom"], "warning_messages": [], "mutation_type": "type_error__introduce_undefined_variable", "instruction": "Fix the type errors in this Compact contract", "expected_output": "pragma language_version >= 0.13.0;\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 4) as Uint<4> }];\n    } else {\n      assert cell.x < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n\n}\n"}
{"source_contract": "GameCommons.compact", "source_filename": "GameCommons.compact_type_error", "code": "pragma language_version >= 0.13.0;\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(extra_arg): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 4) as Uint<4> }];\n    } else {\n      assert cell.x < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(extra_arg): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 4) as Uint<4> }];\n    } else {\n      assert cell.x < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173505.compact line 28, char 49:\n  parse error: found \")\" looking for \":\"\n", "error_messages": ["parse error: found \")\" looking for \":\""], "warning_messages": [], "compilation_time_ms": 420.846, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173505.compact", "timestamp": "2025-06-05T17:35:05.727824"}, "error_messages": ["parse error: found \")\" looking for \":\""], "warning_messages": [], "mutation_type": "type_error__introduce_wrong_function_args", "instruction": "Fix the type errors in this Compact contract", "expected_output": "pragma language_version >= 0.13.0;\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 4) as Uint<4> }];\n    } else {\n      assert cell.x < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n\n}\n"}
{"source_contract": "token.compact", "source_filename": "token.compact_type_error", "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: String;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: String;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173506.compact line 9, char 20:\n  unbound identifier String\n", "error_messages": [], "warning_messages": [], "compilation_time_ms": 461.377, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173506.compact", "timestamp": "2025-06-05T17:35:06.149023"}, "error_messages": [], "warning_messages": [], "mutation_type": "type_error__introduce_type_mismatch", "instruction": "Fix the type errors in this Compact contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n"}
{"source_contract": "token.compact", "source_filename": "token.compact_type_error", "code": "pragma language_version >= undefined_variable + 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= undefined_variable + 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173506.compact line 1, char 28:\n  parse error: found \"undefined_variable\" looking for a version atom\n", "error_messages": ["parse error: found \"undefined_variable\" looking for a version atom"], "warning_messages": [], "compilation_time_ms": 412.03499999999997, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173506.compact", "timestamp": "2025-06-05T17:35:06.610719"}, "error_messages": ["parse error: found \"undefined_variable\" looking for a version atom"], "warning_messages": [], "mutation_type": "type_error__introduce_undefined_variable", "instruction": "Fix the type errors in this Compact contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n"}
{"source_contract": "token.compact", "source_filename": "token.compact_type_error", "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(extra_arg): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(extra_arg): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173507.compact line 15, char 30:\n  parse error: found \")\" looking for \":\"\n", "error_messages": ["parse error: found \")\" looking for \":\""], "warning_messages": [], "compilation_time_ms": 410.69899999999996, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173507.compact", "timestamp": "2025-06-05T17:35:07.023096"}, "error_messages": ["parse error: found \")\" looking for \":\""], "warning_messages": [], "mutation_type": "type_error__introduce_wrong_function_args", "instruction": "Fix the type errors in this Compact contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n"}
{"source_contract": "Crypto.compact", "source_filename": "Crypto.compact_logic_error", "code": "pragma language_version >= 0.14.0;\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n  while (true) { }\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Left-hand side: s * B\n    const lhs: CurvePoint = ec_mul_generator(s);\n\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n  }\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0;\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n  while (true) { }\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Left-hand side: s * B\n    const lhs: CurvePoint = ec_mul_generator(s);\n\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n  }\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173507.compact line 7, char 16:\n  parse error: found \"{\" looking for \";\", \",\", \"||\", \"&&\", \"==\", \"!=\", \"as\", \"+\", \"-\", \"*\", \"[\", \".\", \"=\", \"+=\", \"-=\", \"?\", \"<\", \"<=\", \">=\", or \">\"\n", "error_messages": ["parse error: found \"{\" looking for \";\", \",\", \"||\", \"&&\", \"==\", \"!=\", \"as\", \"+\", \"-\", \"*\", \"[\", \".\", \"=\", \"+=\", \"-=\", \"?\", \"<\", \"<=\", \">=\", or \">\""], "warning_messages": [], "compilation_time_ms": 407.291, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173507.compact", "timestamp": "2025-06-05T17:35:07.434113"}, "error_messages": ["parse error: found \"{\" looking for \";\", \",\", \"||\", \"&&\", \"==\", \"!=\", \"as\", \"+\", \"-\", \"*\", \"[\", \".\", \"=\", \"+=\", \"-=\", \"?\", \"<\", \"<=\", \">=\", or \">\""], "warning_messages": [], "mutation_type": "logic_error__introduce_infinite_loop", "instruction": "Fix the logical errors in this Compact contract", "expected_output": "pragma language_version >= 0.14.0;\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Left-hand side: s * B\n    const lhs: CurvePoint = ec_mul_generator(s);\n\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n  }\n}\n"}
{"source_contract": "Crypto.compact", "source_filename": "Crypto.compact_logic_error", "code": "pragma language_version >= 0.14.0; / 0\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Left-hand side: s * B\n    const lhs: CurvePoint = ec_mul_generator(s);\n\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n  }\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0; / 0\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Left-hand side: s * B\n    const lhs: CurvePoint = ec_mul_generator(s);\n\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n  }\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173507.compact line 1, char 37:\n  unexpected character ' '\n", "error_messages": [], "warning_messages": [], "compilation_time_ms": 405.40999999999997, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173507.compact", "timestamp": "2025-06-05T17:35:07.841750"}, "error_messages": [], "warning_messages": [], "mutation_type": "logic_error__introduce_division_by_zero", "instruction": "Fix the logical errors in this Compact contract", "expected_output": "pragma language_version >= 0.14.0;\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Left-hand side: s * B\n    const lhs: CurvePoint = ec_mul_generator(s);\n\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n  }\n}\n"}
{"source_contract": "Crypto.compact", "source_filename": "Crypto.compact_logic_error", "code": "pragma language_version >= 0.14.0;\n  assert false \"This will always fail\";\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Left-hand side: s * B\n    const lhs: CurvePoint = ec_mul_generator(s);\n\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n  }\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0;\n  assert false \"This will always fail\";\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Left-hand side: s * B\n    const lhs: CurvePoint = ec_mul_generator(s);\n\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n  }\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173508.compact line 2, char 3:\n  parse error: found \"assert\" looking for a program element or end of file\n", "error_messages": ["parse error: found \"assert\" looking for a program element or end of file"], "warning_messages": [], "compilation_time_ms": 405.005, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173508.compact", "timestamp": "2025-06-05T17:35:08.247460"}, "error_messages": ["parse error: found \"assert\" looking for a program element or end of file"], "warning_messages": [], "mutation_type": "logic_error__introduce_incorrect_assertions", "instruction": "Fix the logical errors in this Compact contract", "expected_output": "pragma language_version >= 0.14.0;\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Left-hand side: s * B\n    const lhs: CurvePoint = ec_mul_generator(s);\n\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n  }\n}\n"}
{"source_contract": "identity.compact", "source_filename": "identity.compact_logic_error", "code": "pragma language_version >= 0.14.0; / 0\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\nexport { CoinInfo }\nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { subject_hash }\nexport { Signature }\nexport { CredentialSubject }\nexport { SignedCredentialSubject }\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0; / 0\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\nexport { CoinInfo }\nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { subject_hash }\nexport { Signature }\nexport { CredentialSubject }\nexport { SignedCredentialSubject }\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173508.compact line 1, char 37:\n  unexpected character ' '\n", "error_messages": [], "warning_messages": [], "compilation_time_ms": 417.32399999999996, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173508.compact", "timestamp": "2025-06-05T17:35:08.652770"}, "error_messages": [], "warning_messages": [], "mutation_type": "logic_error__introduce_division_by_zero", "instruction": "Fix the logical errors in this Compact contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\nexport { CoinInfo }\nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { subject_hash }\nexport { Signature }\nexport { CredentialSubject }\nexport { SignedCredentialSubject }\n"}
{"source_contract": "identity.compact", "source_filename": "identity.compact_logic_error", "code": "pragma language_version >= 0.14.0;\n  assert false \"This will always fail\";\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\nexport { CoinInfo }\nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { subject_hash }\nexport { Signature }\nexport { CredentialSubject }\nexport { SignedCredentialSubject }\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0;\n  assert false \"This will always fail\";\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\nexport { CoinInfo }\nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { subject_hash }\nexport { Signature }\nexport { CredentialSubject }\nexport { SignedCredentialSubject }\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173509.compact line 2, char 3:\n  parse error: found \"assert\" looking for a program element or end of file\n", "error_messages": ["parse error: found \"assert\" looking for a program element or end of file"], "warning_messages": [], "compilation_time_ms": 411.476, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173509.compact", "timestamp": "2025-06-05T17:35:09.070385"}, "error_messages": ["parse error: found \"assert\" looking for a program element or end of file"], "warning_messages": [], "mutation_type": "logic_error__introduce_incorrect_assertions", "instruction": "Fix the logical errors in this Compact contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\nexport { CoinInfo }\nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { subject_hash }\nexport { Signature }\nexport { CredentialSubject }\nexport { SignedCredentialSubject }\n"}
{"source_contract": "shop.compact", "source_filename": "shop.compact_logic_error", "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n  while (true) { }\n  const order = get_order(id);\n  const identity = get_identity();\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  verify_signature(subject_hash(identity.subject), identity.signature);\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  receive(disclose(order.payment));\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n  while (true) { }\n  const order = get_order(id);\n  const identity = get_identity();\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  verify_signature(subject_hash(identity.subject), identity.signature);\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  receive(disclose(order.payment));\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173509.compact line 40, char 16:\n  parse error: found \"{\" looking for \";\", \",\", \"||\", \"&&\", \"==\", \"!=\", \"as\", \"+\", \"-\", \"*\", \"[\", \".\", \"=\", \"+=\", \"-=\", \"?\", \"<\", \"<=\", \">=\", or \">\"\n", "error_messages": ["parse error: found \"{\" looking for \";\", \",\", \"||\", \"&&\", \"==\", \"!=\", \"as\", \"+\", \"-\", \"*\", \"[\", \".\", \"=\", \"+=\", \"-=\", \"?\", \"<\", \"<=\", \">=\", or \">\""], "warning_messages": [], "compilation_time_ms": 416.825, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173509.compact", "timestamp": "2025-06-05T17:35:09.482157"}, "error_messages": ["parse error: found \"{\" looking for \";\", \",\", \"||\", \"&&\", \"==\", \"!=\", \"as\", \"+\", \"-\", \"*\", \"[\", \".\", \"=\", \"+=\", \"-=\", \"?\", \"<\", \"<=\", \">=\", or \">\""], "warning_messages": [], "mutation_type": "logic_error__introduce_infinite_loop", "instruction": "Fix the logical errors in this Compact contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n  const order = get_order(id);\n  const identity = get_identity();\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  verify_signature(subject_hash(identity.subject), identity.signature);\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  receive(disclose(order.payment));\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}\n"}
{"source_contract": "shop.compact", "source_filename": "shop.compact_logic_error", "code": "pragma language_version >= 0.14.0; / 0\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n  const order = get_order(id);\n  const identity = get_identity();\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  verify_signature(subject_hash(identity.subject), identity.signature);\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  receive(disclose(order.payment));\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0; / 0\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n  const order = get_order(id);\n  const identity = get_identity();\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  verify_signature(subject_hash(identity.subject), identity.signature);\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  receive(disclose(order.payment));\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173509.compact line 1, char 37:\n  unexpected character ' '\n", "error_messages": [], "warning_messages": [], "compilation_time_ms": 410.45500000000004, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173509.compact", "timestamp": "2025-06-05T17:35:09.899290"}, "error_messages": [], "warning_messages": [], "mutation_type": "logic_error__introduce_division_by_zero", "instruction": "Fix the logical errors in this Compact contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n  const order = get_order(id);\n  const identity = get_identity();\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  verify_signature(subject_hash(identity.subject), identity.signature);\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  receive(disclose(order.payment));\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}\n"}
{"source_contract": "shop.compact", "source_filename": "shop.compact_logic_error", "code": "pragma language_version >= 0.14.0;\n  assert false \"This will always fail\";\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n  const order = get_order(id);\n  const identity = get_identity();\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  verify_signature(subject_hash(identity.subject), identity.signature);\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  receive(disclose(order.payment));\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0;\n  assert false \"This will always fail\";\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n  const order = get_order(id);\n  const identity = get_identity();\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  verify_signature(subject_hash(identity.subject), identity.signature);\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  receive(disclose(order.payment));\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173510.compact line 2, char 3:\n  parse error: found \"assert\" looking for a program element or end of file\n", "error_messages": ["parse error: found \"assert\" looking for a program element or end of file"], "warning_messages": [], "compilation_time_ms": 404.812, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173510.compact", "timestamp": "2025-06-05T17:35:10.310047"}, "error_messages": ["parse error: found \"assert\" looking for a program element or end of file"], "warning_messages": [], "mutation_type": "logic_error__introduce_incorrect_assertions", "instruction": "Fix the logical errors in this Compact contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n  const order = get_order(id);\n  const identity = get_identity();\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  verify_signature(subject_hash(identity.subject), identity.signature);\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  receive(disclose(order.payment));\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}\n"}
{"source_contract": "registry.compact", "source_filename": "registry.compact_logic_error", "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nexport { CurvePoint }\n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {\n  while (true) { }\n  wallet_public_key = own_public_key();\n  signing_public_key = signing_key;\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nexport { CurvePoint }\n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {\n  while (true) { }\n  wallet_public_key = own_public_key();\n  signing_public_key = signing_key;\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173510.compact line 10, char 16:\n  parse error: found \"{\" looking for \";\", \",\", \"||\", \"&&\", \"==\", \"!=\", \"as\", \"+\", \"-\", \"*\", \"[\", \".\", \"=\", \"+=\", \"-=\", \"?\", \"<\", \"<=\", \">=\", or \">\"\n", "error_messages": ["parse error: found \"{\" looking for \";\", \",\", \"||\", \"&&\", \"==\", \"!=\", \"as\", \"+\", \"-\", \"*\", \"[\", \".\", \"=\", \"+=\", \"-=\", \"?\", \"<\", \"<=\", \">=\", or \">\""], "warning_messages": [], "compilation_time_ms": 416.65999999999997, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173510.compact", "timestamp": "2025-06-05T17:35:10.715144"}, "error_messages": ["parse error: found \"{\" looking for \";\", \",\", \"||\", \"&&\", \"==\", \"!=\", \"as\", \"+\", \"-\", \"*\", \"[\", \".\", \"=\", \"+=\", \"-=\", \"?\", \"<\", \"<=\", \">=\", or \">\""], "warning_messages": [], "mutation_type": "logic_error__introduce_infinite_loop", "instruction": "Fix the logical errors in this Compact contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nexport { CurvePoint }\n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {\n  wallet_public_key = own_public_key();\n  signing_public_key = signing_key;\n}\n"}
{"source_contract": "registry.compact", "source_filename": "registry.compact_logic_error", "code": "pragma language_version >= 0.14.0; / 0\n\nimport CompactStandardLibrary;\nexport { CurvePoint }\n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {\n  wallet_public_key = own_public_key();\n  signing_public_key = signing_key;\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0; / 0\n\nimport CompactStandardLibrary;\nexport { CurvePoint }\n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {\n  wallet_public_key = own_public_key();\n  signing_public_key = signing_key;\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173511.compact line 1, char 37:\n  unexpected character ' '\n", "error_messages": [], "warning_messages": [], "compilation_time_ms": 417.076, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173511.compact", "timestamp": "2025-06-05T17:35:11.132099"}, "error_messages": [], "warning_messages": [], "mutation_type": "logic_error__introduce_division_by_zero", "instruction": "Fix the logical errors in this Compact contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nexport { CurvePoint }\n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {\n  wallet_public_key = own_public_key();\n  signing_public_key = signing_key;\n}\n"}
{"source_contract": "registry.compact", "source_filename": "registry.compact_logic_error", "code": "pragma language_version >= 0.14.0;\n  assert false \"This will always fail\";\n\nimport CompactStandardLibrary;\nexport { CurvePoint }\n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {\n  wallet_public_key = own_public_key();\n  signing_public_key = signing_key;\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0;\n  assert false \"This will always fail\";\n\nimport CompactStandardLibrary;\nexport { CurvePoint }\n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {\n  wallet_public_key = own_public_key();\n  signing_public_key = signing_key;\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173511.compact line 2, char 3:\n  parse error: found \"assert\" looking for a program element or end of file\n", "error_messages": ["parse error: found \"assert\" looking for a program element or end of file"], "warning_messages": [], "compilation_time_ms": 409.892, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173511.compact", "timestamp": "2025-06-05T17:35:11.549467"}, "error_messages": ["parse error: found \"assert\" looking for a program element or end of file"], "warning_messages": [], "mutation_type": "logic_error__introduce_incorrect_assertions", "instruction": "Fix the logical errors in this Compact contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nexport { CurvePoint }\n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {\n  wallet_public_key = own_public_key();\n  signing_public_key = signing_key;\n}\n"}
{"source_contract": "token.compact", "source_filename": "token.compact_logic_error", "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  while (true) { }\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  while (true) { }\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173511.compact line 16, char 16:\n  parse error: found \"{\" looking for \";\", \",\", \"||\", \"&&\", \"==\", \"!=\", \"as\", \"+\", \"-\", \"*\", \"[\", \".\", \"=\", \"+=\", \"-=\", \"?\", \"<\", \"<=\", \">=\", or \">\"\n", "error_messages": ["parse error: found \"{\" looking for \";\", \",\", \"||\", \"&&\", \"==\", \"!=\", \"as\", \"+\", \"-\", \"*\", \"[\", \".\", \"=\", \"+=\", \"-=\", \"?\", \"<\", \"<=\", \">=\", or \">\""], "warning_messages": [], "compilation_time_ms": 436.46000000000004, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173511.compact", "timestamp": "2025-06-05T17:35:11.959651"}, "error_messages": ["parse error: found \"{\" looking for \";\", \",\", \"||\", \"&&\", \"==\", \"!=\", \"as\", \"+\", \"-\", \"*\", \"[\", \".\", \"=\", \"+=\", \"-=\", \"?\", \"<\", \"<=\", \">=\", or \">\""], "warning_messages": [], "mutation_type": "logic_error__introduce_infinite_loop", "instruction": "Fix the logical errors in this Compact contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n"}
{"source_contract": "token.compact", "source_filename": "token.compact_logic_error", "code": "pragma language_version >= 0.13.0; / 0\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0; / 0\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173512.compact line 1, char 37:\n  unexpected character ' '\n", "error_messages": [], "warning_messages": [], "compilation_time_ms": 468.613, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173512.compact", "timestamp": "2025-06-05T17:35:12.396445"}, "error_messages": [], "warning_messages": [], "mutation_type": "logic_error__introduce_division_by_zero", "instruction": "Fix the logical errors in this Compact contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n"}
{"source_contract": "token.compact", "source_filename": "token.compact_logic_error", "code": "pragma language_version >= 0.13.0;\n  assert false \"This will always fail\";\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n  assert false \"This will always fail\";\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173512.compact line 2, char 3:\n  parse error: found \"assert\" looking for a program element or end of file\n", "error_messages": ["parse error: found \"assert\" looking for a program element or end of file"], "warning_messages": [], "compilation_time_ms": 406.673, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173512.compact", "timestamp": "2025-06-05T17:35:12.865418"}, "error_messages": ["parse error: found \"assert\" looking for a program element or end of file"], "warning_messages": [], "mutation_type": "logic_error__introduce_incorrect_assertions", "instruction": "Fix the logical errors in this Compact contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n"}
{"source_contract": "battleship_west.compact", "source_filename": "battleship_west.compact_logic_error", "code": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  while (true) { }\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s51, ship_cell: ships.s51, ship_v: ships.v51 };\n    return get_shot_result<5>(shot_attempt, updated_ship_state.s51, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  while (true) { }\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s51, ship_cell: ships.s51, ship_v: ships.v51 };\n    return get_shot_result<5>(shot_attempt, updated_ship_state.s51, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173513.compact line 88, char 16:\n  parse error: found \"{\" looking for \";\", \",\", \"||\", \"&&\", \"==\", \"!=\", \"as\", \"+\", \"-\", \"*\", \"[\", \".\", \"=\", \"+=\", \"-=\", \"?\", \"<\", \"<=\", \">=\", or \">\"\n", "error_messages": ["parse error: found \"{\" looking for \";\", \",\", \"||\", \"&&\", \"==\", \"!=\", \"as\", \"+\", \"-\", \"*\", \"[\", \".\", \"=\", \"+=\", \"-=\", \"?\", \"<\", \"<=\", \">=\", or \">\""], "warning_messages": [], "compilation_time_ms": 425.022, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173513.compact", "timestamp": "2025-06-05T17:35:13.272436"}, "error_messages": ["parse error: found \"{\" looking for \";\", \",\", \"||\", \"&&\", \"==\", \"!=\", \"as\", \"+\", \"-\", \"*\", \"[\", \".\", \"=\", \"+=\", \"-=\", \"?\", \"<\", \"<=\", \">=\", or \">\""], "warning_messages": [], "mutation_type": "logic_error__introduce_infinite_loop", "instruction": "Fix the logical errors in this Compact contract", "expected_output": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s51, ship_cell: ships.s51, ship_v: ships.v51 };\n    return get_shot_result<5>(shot_attempt, updated_ship_state.s51, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n"}
{"source_contract": "battleship_west.compact", "source_filename": "battleship_west.compact_logic_error", "code": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0; / 0\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s51, ship_cell: ships.s51, ship_v: ships.v51 };\n    return get_shot_result<5>(shot_attempt, updated_ship_state.s51, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0; / 0\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s51, ship_cell: ships.s51, ship_v: ships.v51 };\n    return get_shot_result<5>(shot_attempt, updated_ship_state.s51, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173513.compact line 10, char 37:\n  unexpected character ' '\n", "error_messages": [], "warning_messages": [], "compilation_time_ms": 496.625, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173513.compact", "timestamp": "2025-06-05T17:35:13.697801"}, "error_messages": [], "warning_messages": [], "mutation_type": "logic_error__introduce_division_by_zero", "instruction": "Fix the logical errors in this Compact contract", "expected_output": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s51, ship_cell: ships.s51, ship_v: ships.v51 };\n    return get_shot_result<5>(shot_attempt, updated_ship_state.s51, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n"}
{"source_contract": "battleship_west.compact", "source_filename": "battleship_west.compact_logic_error", "code": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n  assert false \"This will always fail\";\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s51, ship_cell: ships.s51, ship_v: ships.v51 };\n    return get_shot_result<5>(shot_attempt, updated_ship_state.s51, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n  assert false \"This will always fail\";\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s51, ship_cell: ships.s51, ship_v: ships.v51 };\n    return get_shot_result<5>(shot_attempt, updated_ship_state.s51, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173514.compact line 2, char 3:\n  parse error: found \"assert\" looking for a program element or end of file\n", "error_messages": ["parse error: found \"assert\" looking for a program element or end of file"], "warning_messages": [], "compilation_time_ms": 405.006, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173514.compact", "timestamp": "2025-06-05T17:35:14.194766"}, "error_messages": ["parse error: found \"assert\" looking for a program element or end of file"], "warning_messages": [], "mutation_type": "logic_error__introduce_incorrect_assertions", "instruction": "Fix the logical errors in this Compact contract", "expected_output": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s51, ship_cell: ships.s51, ship_v: ships.v51 };\n    return get_shot_result<5>(shot_attempt, updated_ship_state.s51, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n"}
{"source_contract": "battleship_east.compact", "source_filename": "battleship_east.compact_logic_error", "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  while (true) { }\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\n\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x - 1, y: cell.y},\n      Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  while (true) { }\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\n\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x - 1, y: cell.y},\n      Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173514.compact line 79, char 16:\n  parse error: found \"{\" looking for \";\", \",\", \"||\", \"&&\", \"==\", \"!=\", \"as\", \"+\", \"-\", \"*\", \"[\", \".\", \"=\", \"+=\", \"-=\", \"?\", \"<\", \"<=\", \">=\", or \">\"\n", "error_messages": ["parse error: found \"{\" looking for \";\", \",\", \"||\", \"&&\", \"==\", \"!=\", \"as\", \"+\", \"-\", \"*\", \"[\", \".\", \"=\", \"+=\", \"-=\", \"?\", \"<\", \"<=\", \">=\", or \">\""], "warning_messages": [], "compilation_time_ms": 416.70099999999996, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173514.compact", "timestamp": "2025-06-05T17:35:14.600101"}, "error_messages": ["parse error: found \"{\" looking for \";\", \",\", \"||\", \"&&\", \"==\", \"!=\", \"as\", \"+\", \"-\", \"*\", \"[\", \".\", \"=\", \"+=\", \"-=\", \"?\", \"<\", \"<=\", \">=\", or \">\""], "warning_messages": [], "mutation_type": "logic_error__introduce_infinite_loop", "instruction": "Fix the logical errors in this Compact contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\n\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x - 1, y: cell.y},\n      Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n}\n"}
{"source_contract": "battleship_east.compact", "source_filename": "battleship_east.compact_logic_error", "code": "pragma language_version >= 0.13.0; / 0\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\n\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x - 1, y: cell.y},\n      Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0; / 0\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\n\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x - 1, y: cell.y},\n      Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173515.compact line 1, char 37:\n  unexpected character ' '\n", "error_messages": [], "warning_messages": [], "compilation_time_ms": 410.524, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173515.compact", "timestamp": "2025-06-05T17:35:15.017181"}, "error_messages": [], "warning_messages": [], "mutation_type": "logic_error__introduce_division_by_zero", "instruction": "Fix the logical errors in this Compact contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\n\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x - 1, y: cell.y},\n      Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n}\n"}
{"source_contract": "battleship_east.compact", "source_filename": "battleship_east.compact_logic_error", "code": "pragma language_version >= 0.13.0;\n  assert false \"This will always fail\";\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\n\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x - 1, y: cell.y},\n      Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n  assert false \"This will always fail\";\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\n\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x - 1, y: cell.y},\n      Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173515.compact line 2, char 3:\n  parse error: found \"assert\" looking for a program element or end of file\n", "error_messages": ["parse error: found \"assert\" looking for a program element or end of file"], "warning_messages": [], "compilation_time_ms": 404.734, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173515.compact", "timestamp": "2025-06-05T17:35:15.428049"}, "error_messages": ["parse error: found \"assert\" looking for a program element or end of file"], "warning_messages": [], "mutation_type": "logic_error__introduce_incorrect_assertions", "instruction": "Fix the logical errors in this Compact contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\n\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x - 1, y: cell.y},\n      Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n}\n"}
{"source_contract": "GameCommons.compact", "source_filename": "GameCommons.compact_logic_error", "code": "pragma language_version >= 0.13.0;\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n  while (true) { }\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 4) as Uint<4> }];\n    } else {\n      assert cell.x < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n  while (true) { }\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 4) as Uint<4> }];\n    } else {\n      assert cell.x < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173515.compact line 29, char 16:\n  parse error: found \"{\" looking for \";\", \",\", \"||\", \"&&\", \"==\", \"!=\", \"as\", \"+\", \"-\", \"*\", \"[\", \".\", \"=\", \"+=\", \"-=\", \"?\", \"<\", \"<=\", \">=\", or \">\"\n", "error_messages": ["parse error: found \"{\" looking for \";\", \",\", \"||\", \"&&\", \"==\", \"!=\", \"as\", \"+\", \"-\", \"*\", \"[\", \".\", \"=\", \"+=\", \"-=\", \"?\", \"<\", \"<=\", \">=\", or \">\""], "warning_messages": [], "compilation_time_ms": 412.843, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173515.compact", "timestamp": "2025-06-05T17:35:15.833111"}, "error_messages": ["parse error: found \"{\" looking for \";\", \",\", \"||\", \"&&\", \"==\", \"!=\", \"as\", \"+\", \"-\", \"*\", \"[\", \".\", \"=\", \"+=\", \"-=\", \"?\", \"<\", \"<=\", \">=\", or \">\""], "warning_messages": [], "mutation_type": "logic_error__introduce_infinite_loop", "instruction": "Fix the logical errors in this Compact contract", "expected_output": "pragma language_version >= 0.13.0;\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 4) as Uint<4> }];\n    } else {\n      assert cell.x < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n\n}\n"}
{"source_contract": "GameCommons.compact", "source_filename": "GameCommons.compact_logic_error", "code": "pragma language_version >= 0.13.0; / 0\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 4) as Uint<4> }];\n    } else {\n      assert cell.x < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0; / 0\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 4) as Uint<4> }];\n    } else {\n      assert cell.x < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173516.compact line 1, char 37:\n  unexpected character ' '\n", "error_messages": [], "warning_messages": [], "compilation_time_ms": 407.22999999999996, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173516.compact", "timestamp": "2025-06-05T17:35:16.246233"}, "error_messages": [], "warning_messages": [], "mutation_type": "logic_error__introduce_division_by_zero", "instruction": "Fix the logical errors in this Compact contract", "expected_output": "pragma language_version >= 0.13.0;\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 4) as Uint<4> }];\n    } else {\n      assert cell.x < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n\n}\n"}
{"source_contract": "GameCommons.compact", "source_filename": "GameCommons.compact_logic_error", "code": "pragma language_version >= 0.13.0;\n  assert false \"This will always fail\";\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 4) as Uint<4> }];\n    } else {\n      assert cell.x < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n  assert false \"This will always fail\";\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 4) as Uint<4> }];\n    } else {\n      assert cell.x < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173516.compact line 2, char 3:\n  parse error: found \"assert\" looking for a program element or end of file\n", "error_messages": ["parse error: found \"assert\" looking for a program element or end of file"], "warning_messages": [], "compilation_time_ms": 410.221, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173516.compact", "timestamp": "2025-06-05T17:35:16.653776"}, "error_messages": ["parse error: found \"assert\" looking for a program element or end of file"], "warning_messages": [], "mutation_type": "logic_error__introduce_incorrect_assertions", "instruction": "Fix the logical errors in this Compact contract", "expected_output": "pragma language_version >= 0.13.0;\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 4) as Uint<4> }];\n    } else {\n      assert cell.x < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n\n}\n"}
{"source_contract": "token.compact", "source_filename": "token.compact_logic_error", "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  while (true) { }\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  while (true) { }\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173517.compact line 16, char 16:\n  parse error: found \"{\" looking for \";\", \",\", \"||\", \"&&\", \"==\", \"!=\", \"as\", \"+\", \"-\", \"*\", \"[\", \".\", \"=\", \"+=\", \"-=\", \"?\", \"<\", \"<=\", \">=\", or \">\"\n", "error_messages": ["parse error: found \"{\" looking for \";\", \",\", \"||\", \"&&\", \"==\", \"!=\", \"as\", \"+\", \"-\", \"*\", \"[\", \".\", \"=\", \"+=\", \"-=\", \"?\", \"<\", \"<=\", \">=\", or \">\""], "warning_messages": [], "compilation_time_ms": 415.182, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173517.compact", "timestamp": "2025-06-05T17:35:17.064289"}, "error_messages": ["parse error: found \"{\" looking for \";\", \",\", \"||\", \"&&\", \"==\", \"!=\", \"as\", \"+\", \"-\", \"*\", \"[\", \".\", \"=\", \"+=\", \"-=\", \"?\", \"<\", \"<=\", \">=\", or \">\""], "warning_messages": [], "mutation_type": "logic_error__introduce_infinite_loop", "instruction": "Fix the logical errors in this Compact contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n"}
{"source_contract": "token.compact", "source_filename": "token.compact_logic_error", "code": "pragma language_version >= 0.13.0; / 0\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0; / 0\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173517.compact line 1, char 37:\n  unexpected character ' '\n", "error_messages": [], "warning_messages": [], "compilation_time_ms": 405.94, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173517.compact", "timestamp": "2025-06-05T17:35:17.479744"}, "error_messages": [], "warning_messages": [], "mutation_type": "logic_error__introduce_division_by_zero", "instruction": "Fix the logical errors in this Compact contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n"}
{"source_contract": "token.compact", "source_filename": "token.compact_logic_error", "code": "pragma language_version >= 0.13.0;\n  assert false \"This will always fail\";\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n  assert false \"This will always fail\";\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173517.compact line 2, char 3:\n  parse error: found \"assert\" looking for a program element or end of file\n", "error_messages": ["parse error: found \"assert\" looking for a program element or end of file"], "warning_messages": [], "compilation_time_ms": 413.231, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173517.compact", "timestamp": "2025-06-05T17:35:17.885966"}, "error_messages": ["parse error: found \"assert\" looking for a program element or end of file"], "warning_messages": [], "mutation_type": "logic_error__introduce_incorrect_assertions", "instruction": "Fix the logical errors in this Compact contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n"}
{"source_contract": "Crypto.compact", "source_filename": "Crypto.compact_incomplete_0", "code": "pragma language_version >= 0.14.0;\n\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n    pk: CurvePoint;\n    R: CurvePoint;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n    // Left-hand side: s * B\n    const lhs: CurvePoint = ec_mul_generator(s);\n\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0;\n\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n    pk: CurvePoint;\n    R: CurvePoint;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n    // Left-hand side: s * B\n    const lhs: CurvePoint = ec_mul_generator(s);\n\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173518.compact line 20, char 5:\n  parse error: found \"pk\" looking for a program element, end of file, or \";\"\n", "error_messages": ["parse error: found \"pk\" looking for a program element, end of file, or \";\""], "warning_messages": [], "compilation_time_ms": 410.961, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173518.compact", "timestamp": "2025-06-05T17:35:18.299614"}, "error_messages": ["parse error: found \"pk\" looking for a program element, end of file, or \";\""], "warning_messages": [], "mutation_type": "incomplete_variation_0", "instruction": "Complete this Compact smart contract", "expected_output": "pragma language_version >= 0.14.0;\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Left-hand side: s * B\n    const lhs: CurvePoint = ec_mul_generator(s);\n\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n  }\n}\n"}
{"source_contract": "Crypto.compact", "source_filename": "Crypto.compact_incomplete_1", "code": "\nmodule Crypto {\n  import CompactStandardLibrary;\n\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n  }\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b2: msg\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    const lhs: CurvePoint = ec_mul_generator(s);\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n  }\n}", "is_valid": false, "compilation_result": {"success": false, "code": "\nmodule Crypto {\n  import CompactStandardLibrary;\n\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n  }\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b2: msg\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    const lhs: CurvePoint = ec_mul_generator(s);\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n  }\n}", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173518.compact line 5, char 5:\n  parse error: found \"return\" looking for a program element or \"}\"\n", "error_messages": ["parse error: found \"return\" looking for a program element or \"}\""], "warning_messages": [], "compilation_time_ms": 406.59499999999997, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173518.compact", "timestamp": "2025-06-05T17:35:18.710855"}, "error_messages": ["parse error: found \"return\" looking for a program element or \"}\""], "warning_messages": [], "mutation_type": "incomplete_variation_1", "instruction": "Complete this Compact smart contract", "expected_output": "pragma language_version >= 0.14.0;\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Left-hand side: s * B\n    const lhs: CurvePoint = ec_mul_generator(s);\n\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n  }\n}\n"}
{"source_contract": "Crypto.compact", "source_filename": "Crypto.compact_incomplete_2", "code": "pragma language_version >= 0.14.0;\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0;\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173519.compact line 72, char 7:\n  parse error: found end of file looking for a statement or \"}\"\n", "error_messages": ["parse error: found end of file looking for a statement or \"}\""], "warning_messages": [], "compilation_time_ms": 425.341, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173519.compact", "timestamp": "2025-06-05T17:35:19.117763"}, "error_messages": ["parse error: found end of file looking for a statement or \"}\""], "warning_messages": [], "mutation_type": "incomplete_variation_2", "instruction": "Complete this Compact smart contract", "expected_output": "pragma language_version >= 0.14.0;\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Left-hand side: s * B\n    const lhs: CurvePoint = ec_mul_generator(s);\n\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n  }\n}\n"}
{"source_contract": "Crypto.compact", "source_filename": "Crypto.compact_incomplete_3", "code": "pragma language_version >= 0.14.0;\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0;\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173519.compact line 83, char 5:\n  parse error: found end of file looking for a statement or \"}\"\n", "error_messages": ["parse error: found end of file looking for a statement or \"}\""], "warning_messages": [], "compilation_time_ms": 419.699, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173519.compact", "timestamp": "2025-06-05T17:35:19.543404"}, "error_messages": ["parse error: found end of file looking for a statement or \"}\""], "warning_messages": [], "mutation_type": "incomplete_variation_3", "instruction": "Complete this Compact smart contract", "expected_output": "pragma language_version >= 0.14.0;\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Left-hand side: s * B\n    const lhs: CurvePoint = ec_mul_generator(s);\n\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n  }\n}\n"}
{"source_contract": "identity.compact", "source_filename": "identity.compact_incomplete_0", "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nexport { CoinInfo }\nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { subject_hash }\nexport { Signature }\nexport { CredentialSubject }\nexport { SignedCredentialSubject }\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nexport { CoinInfo }\nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { subject_hash }\nexport { Signature }\nexport { CredentialSubject }\nexport { SignedCredentialSubject }\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173519.compact line 11, char 1:\n  unbound identifier SignedCredentialSubject\n", "error_messages": [], "warning_messages": [], "compilation_time_ms": 411.98699999999997, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173519.compact", "timestamp": "2025-06-05T17:35:19.963453"}, "error_messages": [], "warning_messages": [], "mutation_type": "incomplete_variation_0", "instruction": "Complete this Compact smart contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\nexport { CoinInfo }\nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { subject_hash }\nexport { Signature }\nexport { CredentialSubject }\nexport { SignedCredentialSubject }\n"}
{"source_contract": "identity.compact", "source_filename": "identity.compact_incomplete_1", "code": "\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\nexport { CoinInfo }\nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { Signature }\nexport { CredentialSubject }\nexport { SignedCredentialSubject }\n", "is_valid": false, "compilation_result": {"success": false, "code": "\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\nexport { CoinInfo }\nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { Signature }\nexport { CredentialSubject }\nexport { SignedCredentialSubject }\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173520.compact line 3, char 1:\n  failed to locate file \"../../crypto/Crypto.compact\"\n", "error_messages": ["failed to locate file \"../../crypto/Crypto.compact\""], "warning_messages": [], "compilation_time_ms": 408.193, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173520.compact", "timestamp": "2025-06-05T17:35:20.375729"}, "error_messages": ["failed to locate file \"../../crypto/Crypto.compact\""], "warning_messages": [], "mutation_type": "incomplete_variation_1", "instruction": "Complete this Compact smart contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\nexport { CoinInfo }\nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { subject_hash }\nexport { Signature }\nexport { CredentialSubject }\nexport { SignedCredentialSubject }\n"}
{"source_contract": "identity.compact", "source_filename": "identity.compact_incomplete_2", "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\nexport { CoinInfo }\nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { subject_hash }", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\nexport { CoinInfo }\nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { subject_hash }", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173520.compact line 4, char 1:\n  failed to locate file \"../../crypto/Crypto.compact\"\n", "error_messages": ["failed to locate file \"../../crypto/Crypto.compact\""], "warning_messages": [], "compilation_time_ms": 429.342, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173520.compact", "timestamp": "2025-06-05T17:35:20.784197"}, "error_messages": ["failed to locate file \"../../crypto/Crypto.compact\""], "warning_messages": [], "mutation_type": "incomplete_variation_2", "instruction": "Complete this Compact smart contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\nexport { CoinInfo }\nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { subject_hash }\nexport { Signature }\nexport { CredentialSubject }\nexport { SignedCredentialSubject }\n"}
{"source_contract": "identity.compact", "source_filename": "identity.compact_incomplete_3", "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\nexport { CoinInfo }\nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { subject_hash }\nexport { Signature }", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\nexport { CoinInfo }\nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { subject_hash }\nexport { Signature }", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173521.compact line 4, char 1:\n  failed to locate file \"../../crypto/Crypto.compact\"\n", "error_messages": ["failed to locate file \"../../crypto/Crypto.compact\""], "warning_messages": [], "compilation_time_ms": 437.15700000000004, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173521.compact", "timestamp": "2025-06-05T17:35:21.213903"}, "error_messages": ["failed to locate file \"../../crypto/Crypto.compact\""], "warning_messages": [], "mutation_type": "incomplete_variation_3", "instruction": "Complete this Compact smart contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\nexport { CoinInfo }\nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { subject_hash }\nexport { Signature }\nexport { CredentialSubject }\nexport { SignedCredentialSubject }\n"}
{"source_contract": "shop.compact", "source_filename": "shop.compact_incomplete_0", "code": "pragma language_version >= 0.14.0;\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n  const order = get_order(id);\n  const identity = get_identity();\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  verify_signature(subject_hash(identity.subject), identity.signature);\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0;\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n  const order = get_order(id);\n  const identity = get_identity();\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  verify_signature(subject_hash(identity.subject), identity.signature);\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173521.compact line 36, char 1:\n  parse error: found \"export\" looking for a statement or \"}\"\n", "error_messages": ["parse error: found \"export\" looking for a statement or \"}\""], "warning_messages": [], "compilation_time_ms": 422.815, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173521.compact", "timestamp": "2025-06-05T17:35:21.651506"}, "error_messages": ["parse error: found \"export\" looking for a statement or \"}\""], "warning_messages": [], "mutation_type": "incomplete_variation_0", "instruction": "Complete this Compact smart contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n  const order = get_order(id);\n  const identity = get_identity();\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  verify_signature(subject_hash(identity.subject), identity.signature);\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  receive(disclose(order.payment));\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}\n"}
{"source_contract": "shop.compact", "source_filename": "shop.compact_incomplete_1", "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  receive(disclose(order.payment));\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  receive(disclose(order.payment));\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173522.compact line 21, char 3:\n  parse error: found \"available_items\" looking for a program element or end of file\n", "error_messages": ["parse error: found \"available_items\" looking for a program element or end of file"], "warning_messages": [], "compilation_time_ms": 411.065, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173522.compact", "timestamp": "2025-06-05T17:35:22.074621"}, "error_messages": ["parse error: found \"available_items\" looking for a program element or end of file"], "warning_messages": [], "mutation_type": "incomplete_variation_1", "instruction": "Complete this Compact smart contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n  const order = get_order(id);\n  const identity = get_identity();\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  verify_signature(subject_hash(identity.subject), identity.signature);\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  receive(disclose(order.payment));\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}\n"}
{"source_contract": "shop.compact", "source_filename": "shop.compact_incomplete_2", "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173522.compact line 4, char 1:\n  failed to locate file \"../../crypto/Crypto.compact\"\n", "error_messages": ["failed to locate file \"../../crypto/Crypto.compact\""], "warning_messages": [], "compilation_time_ms": 427.734, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173522.compact", "timestamp": "2025-06-05T17:35:22.486077"}, "error_messages": ["failed to locate file \"../../crypto/Crypto.compact\""], "warning_messages": [], "mutation_type": "incomplete_variation_2", "instruction": "Complete this Compact smart contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n  const order = get_order(id);\n  const identity = get_identity();\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  verify_signature(subject_hash(identity.subject), identity.signature);\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  receive(disclose(order.payment));\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}\n"}
{"source_contract": "shop.compact", "source_filename": "shop.compact_incomplete_3", "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n  const order = get_order(id);\n  const identity = get_identity();\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n  const order = get_order(id);\n  const identity = get_identity();\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173522.compact line 42, char 1:\n  parse error: found end of file looking for a statement or \"}\"\n", "error_messages": ["parse error: found end of file looking for a statement or \"}\""], "warning_messages": [], "compilation_time_ms": 415.267, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173522.compact", "timestamp": "2025-06-05T17:35:22.914096"}, "error_messages": ["parse error: found end of file looking for a statement or \"}\""], "warning_messages": [], "mutation_type": "incomplete_variation_3", "instruction": "Complete this Compact smart contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\n\nexport { CoinInfo }\nexport { SignedCredentialSubject }\n\nexport struct Order {\n    id: Bytes<16>; // The UUID of the order\n    user_wallet_pk: Bytes<32>; // The public key of the user wallet\n    timestamp: Uint<64>; // The timestamp of the order\n    items: Vector<100, Bytes<16>>; // The items of the order\n    payment: CoinInfo; // The coin info of the order total amount that will be paid\n}\n\nexport sealed ledger expected_coin_color: Bytes<32>;\nexport ledger store_owner_public_key: ZswapCoinPublicKey;\nexport ledger trusted_issuer_public_key: CurvePoint;\nexport ledger available_items: Map<Bytes<16>, Uint<32>>; // Item UUID -> price in tBTC\n\nwitness get_order(id: Bytes<16>): Order; // Retrieve the order details privately\nwitness get_identity(): SignedCredentialSubject; // Retrieve the identity details privately\n\nconstructor(_trusted_issuer_public_key: CurvePoint, token_address: ContractAddress) {\n  // Setup the available items\n  available_items.insert(\"0000000000000000\", 0);\n  available_items.insert(\"0000000000000001\", 2);\n  available_items.insert(\"0000000000000002\", 5);\n  available_items.insert(\"0000000000000003\", 12);\n\n  // Setup the public keys and accepted coin information\n  store_owner_public_key = own_public_key();\n  trusted_issuer_public_key = _trusted_issuer_public_key;\n  expected_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\n// Only accepts valid orders from users that are over 21 years old, and are able to pay for the ordered items\nexport circuit submit_order(id: Bytes<16>): [] {\n  const order = get_order(id);\n  const identity = get_identity();\n\n  assert identity.signature.pk == trusted_issuer_public_key \"The identity is not issued by a trusted issuer\";\n  assert identity.subject.id == own_public_key().bytes \"Provided identity is not matching the wallet owner\";\n  verify_signature(subject_hash(identity.subject), identity.signature);\n  assert order.timestamp - identity.subject.birth_timestamp > 21 * 365 * 24 * 60 * 60 * 1000 \"User is not over 21 years old\";\n  const order_total = fold((acc, item) => (acc + available_items.lookup(item)) as Uint<32>, 0 as Uint<32>, order.items);\n  assert order_total == order.payment.value \"The provided payment amount does not match the order total\";\n  receive(disclose(order.payment));\n  assert order.payment.color == expected_coin_color \"The provided payment is not tBTC\";\n  send_immediate(disclose(order.payment), left<ZswapCoinPublicKey, ContractAddress>(store_owner_public_key), disclose(order.payment.value));\n}\n"}
{"source_contract": "registry.compact", "source_filename": "registry.compact_incomplete_0", "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nexport { CurvePoint }\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {\n  wallet_public_key = own_public_key();\n  signing_public_key = signing_key;\n}\n", "is_valid": true, "compilation_result": {"success": true, "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nexport { CurvePoint }\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {\n  wallet_public_key = own_public_key();\n  signing_public_key = signing_key;\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "", "error_messages": [], "warning_messages": [], "compilation_time_ms": 468.87899999999996, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173523.compact", "timestamp": "2025-06-05T17:35:23.329680"}, "error_messages": [], "warning_messages": [], "mutation_type": "incomplete_variation_0", "instruction": "Complete this Compact smart contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nexport { CurvePoint }\n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {\n  wallet_public_key = own_public_key();\n  signing_public_key = signing_key;\n}\n"}
{"source_contract": "registry.compact", "source_filename": "registry.compact_incomplete_1", "code": "\nexport { CurvePoint }\n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {\n  wallet_public_key = own_public_key();\n  signing_public_key = signing_key;\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "\nexport { CurvePoint }\n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {\n  wallet_public_key = own_public_key();\n  signing_public_key = signing_key;\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173523.compact line 2, char 1:\n  unbound identifier CurvePoint\n", "error_messages": [], "warning_messages": [], "compilation_time_ms": 417.094, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173523.compact", "timestamp": "2025-06-05T17:35:23.799124"}, "error_messages": [], "warning_messages": [], "mutation_type": "incomplete_variation_1", "instruction": "Complete this Compact smart contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nexport { CurvePoint }\n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {\n  wallet_public_key = own_public_key();\n  signing_public_key = signing_key;\n}\n"}
{"source_contract": "registry.compact", "source_filename": "registry.compact_incomplete_2", "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nexport { CurvePoint }\n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nexport { CurvePoint }\n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173524.compact line 9, char 55:\n  parse error: found end of file looking for a statement or \"}\"\n", "error_messages": ["parse error: found end of file looking for a statement or \"}\""], "warning_messages": [], "compilation_time_ms": 419.792, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173524.compact", "timestamp": "2025-06-05T17:35:24.216577"}, "error_messages": ["parse error: found end of file looking for a statement or \"}\""], "warning_messages": [], "mutation_type": "incomplete_variation_2", "instruction": "Complete this Compact smart contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nexport { CurvePoint }\n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {\n  wallet_public_key = own_public_key();\n  signing_public_key = signing_key;\n}\n"}
{"source_contract": "registry.compact", "source_filename": "registry.compact_incomplete_3", "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nexport { CurvePoint }\n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {\n  wallet_public_key = own_public_key();", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nexport { CurvePoint }\n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {\n  wallet_public_key = own_public_key();", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173524.compact line 10, char 40:\n  parse error: found end of file looking for a statement or \"}\"\n", "error_messages": ["parse error: found end of file looking for a statement or \"}\""], "warning_messages": [], "compilation_time_ms": 418.516, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173524.compact", "timestamp": "2025-06-05T17:35:24.636662"}, "error_messages": ["parse error: found end of file looking for a statement or \"}\""], "warning_messages": [], "mutation_type": "incomplete_variation_3", "instruction": "Complete this Compact smart contract", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nexport { CurvePoint }\n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {\n  wallet_public_key = own_public_key();\n  signing_public_key = signing_key;\n}\n"}
{"source_contract": "token.compact", "source_filename": "token.compact_incomplete_0", "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\nconstructor(initNonce: Bytes<32>) {\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "is_valid": true, "compilation_result": {"success": true, "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\nconstructor(initNonce: Bytes<32>) {\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "", "error_messages": [], "warning_messages": [], "compilation_time_ms": 497.21700000000004, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173525.compact", "timestamp": "2025-06-05T17:35:25.055522"}, "error_messages": [], "warning_messages": [], "mutation_type": "incomplete_variation_0", "instruction": "Complete this Compact smart contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n"}
{"source_contract": "token.compact", "source_filename": "token.compact_incomplete_1", "code": "pragma language_version >= 0.13.0;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173525.compact line 19, char 1:\n  parse error: found end of file looking for a statement or \"}\"\n", "error_messages": ["parse error: found end of file looking for a statement or \"}\""], "warning_messages": [], "compilation_time_ms": 420.47, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173525.compact", "timestamp": "2025-06-05T17:35:25.553334"}, "error_messages": ["parse error: found end of file looking for a statement or \"}\""], "warning_messages": [], "mutation_type": "incomplete_variation_1", "instruction": "Complete this Compact smart contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n"}
{"source_contract": "token.compact", "source_filename": "token.compact_incomplete_2", "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173525.compact line 16, char 24:\n  parse error: found end of file looking for a statement or \"}\"\n", "error_messages": ["parse error: found end of file looking for a statement or \"}\""], "warning_messages": [], "compilation_time_ms": 416.59000000000003, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173525.compact", "timestamp": "2025-06-05T17:35:25.974104"}, "error_messages": ["parse error: found end of file looking for a statement or \"}\""], "warning_messages": [], "mutation_type": "incomplete_variation_2", "instruction": "Complete this Compact smart contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n"}
{"source_contract": "token.compact", "source_filename": "token.compact_incomplete_3", "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173526.compact line 18, char 23:\n  parse error: found end of file looking for a statement or \"}\"\n", "error_messages": ["parse error: found end of file looking for a statement or \"}\""], "warning_messages": [], "compilation_time_ms": 412.89799999999997, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173526.compact", "timestamp": "2025-06-05T17:35:26.390992"}, "error_messages": ["parse error: found end of file looking for a statement or \"}\""], "warning_messages": [], "mutation_type": "incomplete_variation_3", "instruction": "Complete this Compact smart contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n"}
{"source_contract": "battleship_west.compact", "source_filename": "battleship_west.compact_incomplete_0", "code": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { public_key }\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n}\n\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s51, ship_cell: ships.s51, ship_v: ships.v51 };\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      ship_def: unknown_ship_def()\n    };\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { public_key }\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n}\n\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s51, ship_cell: ships.s51, ship_v: ships.v51 };\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      ship_def: unknown_ship_def()\n    };\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173526.compact line 155, char 3:\n  parse error: found \"assert\" looking for a program element or end of file\n", "error_messages": ["parse error: found \"assert\" looking for a program element or end of file"], "warning_messages": [], "compilation_time_ms": 464.452, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173526.compact", "timestamp": "2025-06-05T17:35:26.804463"}, "error_messages": ["parse error: found \"assert\" looking for a program element or end of file"], "warning_messages": [], "mutation_type": "incomplete_variation_0", "instruction": "Complete this Compact smart contract", "expected_output": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s51, ship_cell: ships.s51, ship_v: ships.v51 };\n    return get_shot_result<5>(shot_attempt, updated_ship_state.s51, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n"}
{"source_contract": "battleship_west.compact", "source_filename": "battleship_west.compact_incomplete_1", "code": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { ShotResult }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\nexport struct IntermediateShotResult {\n  updated_ship_state: ShipState;\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n  game_state = GAME_STATE.p1_turn;\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n  }\n\n  shot_attempt = value;\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n  } else {\n    return next;\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s51: ship5_cells(ships.s51, ships.v51)\n}\n\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ships: Ships,\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    return get_shot_result<5>(shot_attempt, updated_ship_state.s51, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { ShotResult }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\nexport struct IntermediateShotResult {\n  updated_ship_state: ShipState;\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n  game_state = GAME_STATE.p1_turn;\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n  }\n\n  shot_attempt = value;\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n  } else {\n    return next;\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s51: ship5_cells(ships.s51, ships.v51)\n}\n\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ships: Ships,\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    return get_shot_result<5>(shot_attempt, updated_ship_state.s51, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173527.compact line 42, char 1:\n  parse error: found \"export\" looking for an argument or \"}\"\n", "error_messages": ["parse error: found \"export\" looking for an argument or \"}\""], "warning_messages": [], "compilation_time_ms": 416.153, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173527.compact", "timestamp": "2025-06-05T17:35:27.269221"}, "error_messages": ["parse error: found \"export\" looking for an argument or \"}\""], "warning_messages": [], "mutation_type": "incomplete_variation_1", "instruction": "Complete this Compact smart contract", "expected_output": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s51, ship_cell: ships.s51, ship_v: ships.v51 };\n    return get_shot_result<5>(shot_attempt, updated_ship_state.s51, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n"}
{"source_contract": "battleship_west.compact", "source_filename": "battleship_west.compact_incomplete_2", "code": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner", "is_valid": false, "compilation_result": {"success": false, "code": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173527.compact line 13, char 1:\n  failed to locate file \"../../battleship-contract-commons/GameCommons.compact\"\n", "error_messages": ["failed to locate file \"../../battleship-contract-commons/GameCommons.compact\""], "warning_messages": [], "compilation_time_ms": 482.093, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173527.compact", "timestamp": "2025-06-05T17:35:27.685659"}, "error_messages": ["failed to locate file \"../../battleship-contract-commons/GameCommons.compact\""], "warning_messages": [], "mutation_type": "incomplete_variation_2", "instruction": "Complete this Compact smart contract", "expected_output": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s51, ship_cell: ships.s51, ship_v: ships.v51 };\n    return get_shot_result<5>(shot_attempt, updated_ship_state.s51, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n"}
{"source_contract": "battleship_west.compact", "source_filename": "battleship_west.compact_incomplete_3", "code": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {", "is_valid": false, "compilation_result": {"success": false, "code": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173528.compact line 274, char 74:\n  parse error: found end of file looking for a statement or \"}\"\n", "error_messages": ["parse error: found end of file looking for a statement or \"}\""], "warning_messages": [], "compilation_time_ms": 750.015, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173528.compact", "timestamp": "2025-06-05T17:35:28.168123"}, "error_messages": ["parse error: found end of file looking for a statement or \"}\""], "warning_messages": [], "mutation_type": "incomplete_variation_3", "instruction": "Complete this Compact smart contract", "expected_output": "// The main circuits are join_p1, join_p2, turn_player1, turn_player2, we need 2 players joining to start the game,\n// and then they take turns to shoot at each other's ships until game end conditions are met.\n//\n// Important pattern is implemented by calculating state changes in the contract and submitting them to the player's\n// private state for safe keeping until the next turn. A hash is calculated and stored on ledger to ensure that the\n// player's state is not changed between turns.\n//\n// Keeping a single hash of the whole state object helps to ensure that no private information gets leaked by\n// processing individual ships in specific order, which could reveal which specific ship is hit.\npragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { CoinInfo };\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;              // tracks the current game state according to the game state machine\nexport ledger shot_attempt: Coord;                 // coordinate of the opponent's shot to be validated during the player's turn\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\nexport sealed ledger reward_coin_color: Bytes<32>; // identifier of the coins used for rewards\nexport ledger reward: QualifiedCoinInfo;           // reference to the funds locked in the contract\n\n// Player 1 public state\nexport ledger p1: Maybe<Bytes<32>>;                     // hash of player 1 secret, used to uniquely identify the player\nexport ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // public key of player 1, where to send the reward\nexport ledger p1_ship_positions_hash: Bytes<32>;        // hash of player's board layout, to ensure that it is not changed\nexport ledger p1_ship_state_hash: Bytes<32>;            // hash of player's ships current state, to ensure it is not changed between turns\nexport ledger p1_hit_counter: Counter;                        // counter of hits on player's ships to determine the winner\n\n// Player 2 public state\nexport ledger p2: Maybe<Bytes<32>>;\nexport ledger p2_public_key: Maybe<ZswapCoinPublicKey>;\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\n// Private data provided by each player\nwitness local_secret_key(): Bytes<32>;                      // player's secret key used for identifying the player and hashing the game state\nwitness player_ship_positions(): Ships;                     // ships placement as set by the player at the beginning of the game\nwitness player_ship_state(): ShipState;                     // current state of the player's ships, which ships are hit or sunk\nwitness set_player_ship_state(ship_state: ShipState): []; // used by the contract to update the player's current ship state\n\n// Used to calculate and pass around the shot result during the player's turn\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\n// Tracks the not hit cells of all ships, each ship is represented by a vector of coordinates, which are nullified as they are hit\nexport struct ShipState {\n  s21: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n  s51: Vector<5, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of each ship\n// Each boolean field represents whether each ship is positioned vertically\nexport struct Ships {\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  s51: Coord;\n  v21: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n  v51: Boolean;\n}\n\nconstructor(token_address: ContractAddress) {\n  game_state = GAME_STATE.waiting_p1;\n  reward_coin_color = token_type(pad(32, \"brick_towers_coin\"), token_address);\n}\n\nexport circuit join_p1(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  // We hash the secret key with the unique contract address of each game to get a unique randomness\n  // to use for hashing in each game to avoid matching hashes if a player uses the same board state in several games\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  // Validate and add the reward coin to the contract\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p1_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  // Validate the initial ship positions and compute the current state of the ships\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n\n  // Hash the ship positions, so we can check that user did not change them in their private state later\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(coin: CoinInfo): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  receive(coin);\n  assert coin.value == 100 \"Game requires 100 coins\";\n  assert coin.color == reward_coin_color \"Invalid coin provided\";\n  reward.write_coin(merge_coin_immediate(reward, coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));\n  p2_public_key = some<ZswapCoinPublicKey>(own_public_key());\n\n  const ship_positions = player_ship_positions();\n  assert_valid_ship_position(ship_positions);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  // Basic validation of the opponent's shot\n  assert_valid_coordinate(value);\n\n  // Retrieve and validate the player's ship states\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  // Calculate the shot result and update the ship state\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  // Store the shot attempt for the next player's turn\n  shot_attempt = value;\n\n  // Finally check if this shot ended the game\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\n// Validated that the player has placed their ships correctly\npure circuit assert_valid_ship_position(ship_positions: Ships): [] {\n  const cells = occupied_cells(ship_positions);\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\n// Converts ship positions into a vector of all occupied coordinates\npure circuit occupied_cells(ship_positions: Ships): Vector<17, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n  const s51 = ship5_cells(ship_positions.s51, ship_positions.v51);\n\n  return [\n    s21[0], s21[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3],\n    s51[0], s51[1], s51[2], s51[3], s51[4]\n  ];\n}\n\n// Checks if all the coordinates are unique, i.e. the ships are not overlapping\npure circuit unique_vector(v: Vector<17, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] &&\n          v[14] != v[15] && v[14] != v[16] &&\n          v[15] != v[16]);\n}\n\n// Checks if the game should end and if so, sends the reward to the winner\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 17; // 5 + 4 + 3 + 3 + 2 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p1_public_key.value), reward.value);\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    send(reward, left<ZswapCoinPublicKey, ContractAddress>(p2_public_key.value), reward.value);\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\n// Creates the explicit ship coordinates from the ship position and orientation\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s21: ship2_cells(ships.s21, ships.v21),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41),\n    s51: ship5_cells(ships.s51, ships.v51)\n  };\n}\n\n// Retrieves the current ship state from the player's private state and validates that it is unchanged\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\n// Retrieves the initial ship layout from the player's private state and validates that it is unchanged\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\n// Updates the ship state in the player's private state and returns the new state hash\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\n// Checks if player has hit a ship and returns an updated ship state\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt),\n    s51: update_hit_cell_state<5>(ship_state.s51, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else if (contains<5, Coord>(ship_state.s51, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s51, ship_cell: ships.s51, ship_v: ships.v51 };\n    return get_shot_result<5>(shot_attempt, updated_ship_state.s51, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n"}
{"source_contract": "battleship_east.compact", "source_filename": "battleship_east.compact_incomplete_0", "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s14: Coord;\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n  }\n\n  shot_attempt = value;\n\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n    assert_neighbour_is_not_ship(neighbour, coords);\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\n  for (const neighbour of neighbours) {\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x - 1, y: cell.y},\n      Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s14: Coord;\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n  }\n\n  shot_attempt = value;\n\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n    assert_neighbour_is_not_ship(neighbour, coords);\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\n  for (const neighbour of neighbours) {\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x - 1, y: cell.y},\n      Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173528.compact line 37, char 1:\n  parse error: found \"export\" looking for an argument or \"}\"\n", "error_messages": ["parse error: found \"export\" looking for an argument or \"}\""], "warning_messages": [], "compilation_time_ms": 426.143, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173528.compact", "timestamp": "2025-06-05T17:35:28.919005"}, "error_messages": ["parse error: found \"export\" looking for an argument or \"}\""], "warning_messages": [], "mutation_type": "incomplete_variation_0", "instruction": "Complete this Compact smart contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\n\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x - 1, y: cell.y},\n      Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n}\n"}
{"source_contract": "battleship_east.compact", "source_filename": "battleship_east.compact_incomplete_1", "code": "pragma language_version >= 0.13.0;\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\n\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  updated_ship_state: ShipState;\n}\n\n  s11: Coord;\n  s13: Coord;\n  s14: Coord;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s12: Coord;\n  s14: Coord;\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v41: Boolean;\n}\n\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n\n\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n  }\n\n  shot_attempt = value;\n  game_state = check_winner(GAME_STATE.p1_turn);\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n    return GAME_STATE.p1_wins;\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    updated_ship_state\n  };\n}\n\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n      cell: shot_attempt,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n}\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n  }\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  } else {\n    return horizontal_neighbour4_cells(cell);\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n}\n\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\n\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  updated_ship_state: ShipState;\n}\n\n  s11: Coord;\n  s13: Coord;\n  s14: Coord;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s12: Coord;\n  s14: Coord;\n  s21: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v41: Boolean;\n}\n\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n\n\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n  }\n\n  shot_attempt = value;\n  game_state = check_winner(GAME_STATE.p1_turn);\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n    return GAME_STATE.p1_wins;\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    updated_ship_state\n  };\n}\n\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n      cell: shot_attempt,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n}\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n  }\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  } else {\n    return horizontal_neighbour4_cells(cell);\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n}\n\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173529.compact line 31, char 3:\n  parse error: found \"s11\" looking for a program element, end of file, or \";\"\n", "error_messages": ["parse error: found \"s11\" looking for a program element, end of file, or \";\""], "warning_messages": [], "compilation_time_ms": 412.10200000000003, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173529.compact", "timestamp": "2025-06-05T17:35:29.345518"}, "error_messages": ["parse error: found \"s11\" looking for a program element, end of file, or \";\""], "warning_messages": [], "mutation_type": "incomplete_variation_1", "instruction": "Complete this Compact smart contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\n\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x - 1, y: cell.y},\n      Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n}\n"}
{"source_contract": "battleship_east.compact", "source_filename": "battleship_east.compact_incomplete_2", "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173529.compact line 401, char 11:\n  parse error: found end of file looking for a statement or \"}\"\n", "error_messages": ["parse error: found end of file looking for a statement or \"}\""], "warning_messages": [], "compilation_time_ms": 883.951, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173529.compact", "timestamp": "2025-06-05T17:35:29.757895"}, "error_messages": ["parse error: found end of file looking for a statement or \"}\""], "warning_messages": [], "mutation_type": "incomplete_variation_2", "instruction": "Complete this Compact smart contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\n\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x - 1, y: cell.y},\n      Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n}\n"}
{"source_contract": "battleship_east.compact", "source_filename": "battleship_east.compact_incomplete_3", "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\n\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\n\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173530.compact line 4, char 1:\n  failed to locate file \"../../battleship-contract-commons/GameCommons.compact\"\n", "error_messages": ["failed to locate file \"../../battleship-contract-commons/GameCommons.compact\""], "warning_messages": [], "compilation_time_ms": 515.541, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173530.compact", "timestamp": "2025-06-05T17:35:30.642222"}, "error_messages": ["failed to locate file \"../../battleship-contract-commons/GameCommons.compact\""], "warning_messages": [], "mutation_type": "incomplete_variation_3", "instruction": "Complete this Compact smart contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nimport \"../../battleship-contract-commons/GameCommons\";\n\nexport { Maybe }\nexport { GAME_STATE }\nexport { SHOT_RESULT }\nexport { ShotResult }\nexport { Coord }\nexport { SHIP }\nexport { ShipDef }\nexport { public_key }\n\nexport ledger game_state: GAME_STATE;\nexport ledger shot_attempt: Coord; // coordinate of the opponent's shot\nexport ledger last_shot_result: Maybe<ShotResult>; // validated shot result\n\nexport ledger p1: Maybe<Bytes<32>>; // hash of player 1 secret\nexport ledger p1_ship_positions_hash: Bytes<32>;\nexport ledger p1_ship_state_hash: Bytes<32>;\nexport ledger p1_hit_counter: Counter;\n\nexport ledger p2: Maybe<Bytes<32>>; // hash of player 12secret\nexport ledger p2_ship_positions_hash: Bytes<32>;\nexport ledger p2_ship_state_hash: Bytes<32>;\nexport ledger p2_hit_counter: Counter;\n\nwitness local_secret_key(): Bytes<32>;\nwitness player_ship_positions(): Ships; // ships placement\nwitness player_ship_state(): ShipState; // ship game state, i.e. which cell of ships are hit\nwitness set_player_ship_state(ship_state: ShipState): [];\n\nexport struct IntermediateShotResult {\n  shot_result: ShotResult;\n  updated_ship_state: ShipState;\n}\n\nexport struct ShipState {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Vector<2, Coord>;\n  s22: Vector<2, Coord>;\n  s23: Vector<2, Coord>;\n  s31: Vector<3, Coord>;\n  s32: Vector<3, Coord>;\n  s41: Vector<4, Coord>;\n}\n\n// Ship sizes are fixed and encoded in the field names\n// Each coordinate represents the upper left corner of one ship\n// v21 and v31 are vertical or horizontal flags\nexport struct Ships {\n  s11: Coord;\n  s12: Coord;\n  s13: Coord;\n  s14: Coord;\n  s21: Coord;\n  s22: Coord;\n  s23: Coord;\n  s31: Coord;\n  s32: Coord;\n  s41: Coord;\n  v21: Boolean;\n  v22: Boolean;\n  v23: Boolean;\n  v31: Boolean;\n  v32: Boolean;\n  v41: Boolean;\n}\n\nconstructor() {\n  game_state = GAME_STATE.waiting_p1;\n}\n\nexport circuit join_p1(): [] {\n  assert game_state == GAME_STATE.waiting_p1 \"Attempted to join a game that is not waiting for player 1\";\n  assert !p1.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n  p1 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p1_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p1_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.waiting_p2;\n}\n\nexport circuit join_p2(): [] {\n  assert game_state == GAME_STATE.waiting_p2 \"Attempted to join a game that is not waiting for player 2\";\n  assert !p2.is_some \"Already in the game\";\n  const sk = local_secret_key();\n  // we hash the secret key and the contract address to get a unique hash for the state for each game\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  const me = public_key(sk);\n\n  assert p1.value != me \"Already in the game\";\n  p2 = disclose(some<Bytes<32>>(me));\n\n  const ship_positions = player_ship_positions();\n  const cells = occupied_cells(ship_positions);\n  assert_valid_ship_position(ship_positions, cells);\n\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s11), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s12), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s13), cells);\n  assert_neighbour_is_not_1ship(neighbour1_cells(ship_positions.s14), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s21, ship_positions.v21), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s22, ship_positions.v22), cells);\n  assert_no_adjacent_neighbour_for_2ship(neighbour2_cells(ship_positions.s23, ship_positions.v23), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s31, ship_positions.v31), cells);\n  assert_no_adjacent_neighbour_for_3ship(neighbour3_cells(ship_positions.s32, ship_positions.v32), cells);\n  assert_no_adjacent_neighbour_for_4ship(neighbour4_cells(ship_positions.s41, ship_positions.v41), cells);\n\n  const ship_state = create_ship_state(ship_positions);\n  p2_ship_positions_hash = persistent_commit<Ships>(ship_positions, secret_key);\n  p2_ship_state_hash = update_ship_state(ship_state, secret_key);\n\n  game_state = GAME_STATE.p1_turn;\n}\n\nexport circuit turn_player1(value: Coord): [] {\n  assert game_state == GAME_STATE.p1_turn \"It is not 1st player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p1.value == public_key(sk) \"You are not the 1st player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p1_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p1_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p1.value);\n  p1_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p1_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p2_turn);\n}\n\nexport circuit turn_player2(value: Coord): [] {\n  assert game_state == GAME_STATE.p2_turn \"It is not 2nd player's turn\";\n\n  const sk = local_secret_key();\n  const secret_key = persistent_hash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);\n  assert p2.value == public_key(sk) \"You are not the 2nd player\";\n\n  assert_valid_coordinate(value);\n\n  const ships = get_ships(secret_key, p2_ship_positions_hash);\n  const ship_state = get_ship_state(secret_key, p2_ship_state_hash);\n\n  const result = calculate_shot_result(shot_attempt, ship_state, ships, p2.value);\n  p2_ship_state_hash = update_ship_state(result.updated_ship_state, secret_key);\n  last_shot_result = some<ShotResult>(result.shot_result);\n  if (result.shot_result.result != SHOT_RESULT.miss) {\n    p2_hit_counter.increment(1);\n  }\n\n  shot_attempt = value;\n\n  game_state = check_winner(GAME_STATE.p1_turn);\n}\n\npure circuit assert_valid_ship_position(ship_positions: Ships, cells: Vector<20, Coord>): [] {\n  for (const cell of cells) {\n    assert_valid_coordinate(cell);\n  }\n  assert unique_vector(cells) \"Ship cells must be unique\";\n}\n\npure circuit occupied_cells(ship_positions: Ships): Vector<20, Coord> {\n  const s21 = ship2_cells(ship_positions.s21, ship_positions.v21);\n  const s22 = ship2_cells(ship_positions.s22, ship_positions.v22);\n  const s23 = ship2_cells(ship_positions.s23, ship_positions.v23);\n  const s31 = ship3_cells(ship_positions.s31, ship_positions.v31);\n  const s32 = ship3_cells(ship_positions.s32, ship_positions.v32);\n  const s41 = ship4_cells(ship_positions.s41, ship_positions.v41);\n\n  return [\n    ship_positions.s11, ship_positions.s12, ship_positions.s13, ship_positions.s14,\n    s21[0], s21[1], s22[0], s22[1],  s23[0], s23[1],\n    s31[0], s31[1], s31[2], s32[0], s32[1], s32[2],\n    s41[0], s41[1], s41[2], s41[3]\n  ];\n}\n\npure circuit unique_vector(v: Vector<20, Coord>): Boolean {\n  return (v[0] != v[1] && v[0] != v[2] && v[0] != v[3] && v[0] != v[4] && v[0] != v[5] && v[0] != v[6] && v[0] != v[7] && v[0] != v[8] && v[0] != v[9] && v[0] != v[10] && v[0] != v[11] && v[0] != v[12] && v[0] != v[13] && v[0] != v[14] && v[0] != v[15] && v[0] != v[16] && v[0] != v[17] && v[0] != v[18] && v[0] != v[19] &&\n          v[1] != v[2] && v[1] != v[3] && v[1] != v[4] && v[1] != v[5] && v[1] != v[6] && v[1] != v[7] && v[1] != v[8] && v[1] != v[9] && v[1] != v[10] && v[1] != v[11] && v[1] != v[12] && v[1] != v[13] && v[1] != v[14] && v[1] != v[15] && v[1] != v[16] && v[1] != v[17] && v[1] != v[18] && v[1] != v[19] &&\n          v[2] != v[3] && v[2] != v[4] && v[2] != v[5] && v[2] != v[6] && v[2] != v[7] && v[2] != v[8] && v[2] != v[9] && v[2] != v[10] && v[2] != v[11] && v[2] != v[12] && v[2] != v[13] && v[2] != v[14] && v[2] != v[15] && v[2] != v[16] && v[2] != v[17] && v[2] != v[18] && v[2] != v[19] &&\n          v[3] != v[4] && v[3] != v[5] && v[3] != v[6] && v[3] != v[7] && v[3] != v[8] && v[3] != v[9] && v[3] != v[10] && v[3] != v[11] && v[3] != v[12] && v[3] != v[13] && v[3] != v[14] && v[3] != v[15] && v[3] != v[16] && v[3] != v[17] && v[3] != v[18] && v[3] != v[19] &&\n          v[4] != v[5] && v[4] != v[6] && v[4] != v[7] && v[4] != v[8] && v[4] != v[9] && v[4] != v[10] && v[4] != v[11] && v[4] != v[12] && v[4] != v[13] && v[4] != v[14] && v[4] != v[15] && v[4] != v[16] && v[4] != v[17] && v[4] != v[18] && v[4] != v[19] &&\n          v[5] != v[6] && v[5] != v[7] && v[5] != v[8] && v[5] != v[9] && v[5] != v[10] && v[5] != v[11] && v[5] != v[12] && v[5] != v[13] && v[5] != v[14] && v[5] != v[15] && v[5] != v[16] && v[5] != v[17] && v[5] != v[18] && v[5] != v[19] &&\n          v[6] != v[7] && v[6] != v[8] && v[6] != v[9] && v[6] != v[10] && v[6] != v[11] && v[6] != v[12] && v[6] != v[13] && v[6] != v[14] && v[6] != v[15] && v[6] != v[16] && v[6] != v[17] && v[6] != v[18] && v[6] != v[19] &&\n          v[7] != v[8] && v[7] != v[9] && v[7] != v[10] && v[7] != v[11] && v[7] != v[12] && v[7] != v[13] && v[7] != v[14] && v[7] != v[15] && v[7] != v[16] && v[7] != v[17] && v[7] != v[18] && v[7] != v[19] &&\n          v[8] != v[9] && v[8] != v[10] && v[8] != v[11] && v[8] != v[12] && v[8] != v[13] && v[8] != v[14] && v[8] != v[15] && v[8] != v[16] && v[8] != v[17] && v[8] != v[18] && v[8] != v[19] &&\n          v[9] != v[10] && v[9] != v[11] && v[9] != v[12] && v[9] != v[13] && v[9] != v[14] && v[9] != v[15] && v[9] != v[16] && v[9] != v[17] && v[9] != v[18] && v[9] != v[19] &&\n          v[10] != v[11] && v[10] != v[12] && v[10] != v[13] && v[10] != v[14] && v[10] != v[15] && v[10] != v[16] && v[10] != v[17] && v[10] != v[18] && v[10] != v[19] &&\n          v[11] != v[12] && v[11] != v[13] && v[11] != v[14] && v[11] != v[15] && v[11] != v[16] && v[11] != v[17] && v[11] != v[18] && v[11] != v[19] &&\n          v[12] != v[13] && v[12] != v[14] && v[12] != v[15] && v[12] != v[16] && v[12] != v[17] && v[12] != v[18] && v[12] != v[19] &&\n          v[13] != v[14] && v[13] != v[15] && v[13] != v[16] && v[13] != v[17] && v[13] != v[18] && v[13] != v[19] &&\n          v[14] != v[15] && v[14] != v[16] && v[14] != v[17] && v[14] != v[18] && v[14] != v[19] &&\n          v[15] != v[16] && v[15] != v[17] && v[15] != v[18] && v[15] != v[19] &&\n          v[16] != v[17] && v[16] != v[18] && v[16] != v[19] &&\n          v[17] != v[18] && v[17] != v[19] &&\n          v[18] != v[19]);\n}\n\ncircuit check_winner(next: GAME_STATE): GAME_STATE {\n  const cell_count = 20; // 4 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 1 cells of all ships\n  if (p2_hit_counter == cell_count) {\n    return GAME_STATE.p1_wins;\n  } else if (p1_hit_counter == cell_count) {\n    return GAME_STATE.p2_wins;\n  } else {\n    return next;\n  }\n}\n\npure circuit create_ship_state(ships: Ships): ShipState {\n  return ShipState {\n    s11: ships.s11,\n    s12: ships.s12,\n    s13: ships.s13,\n    s14: ships.s14,\n    s21: ship2_cells(ships.s21, ships.v21),\n    s22: ship2_cells(ships.s22, ships.v22),\n    s23: ship2_cells(ships.s23, ships.v23),\n    s31: ship3_cells(ships.s31, ships.v31),\n    s32: ship3_cells(ships.s32, ships.v32),\n    s41: ship4_cells(ships.s41, ships.v41)\n  };\n}\n\ncircuit get_ship_state(sk: Bytes<32>, expected_state_hash: Bytes<32>): ShipState {\n  const state = player_ship_state();\n  const state_hash = persistent_commit<ShipState>(state, sk);\n  assert state_hash == expected_state_hash \"Ship state hash mismatch\";\n  return state;\n}\n\ncircuit get_ships(sk: Bytes<32>, expected_state_hash: Bytes<32>): Ships {\n  const state = player_ship_positions();\n  const state_hash = persistent_commit<Ships>(state, sk);\n  assert state_hash == expected_state_hash \"Ships hash mismatch\";\n  return state;\n}\n\ncircuit update_ship_state(updated_ship_state: ShipState, sk: Bytes<32>): Bytes<32> {\n  const state_hash = persistent_commit<ShipState>(updated_ship_state, sk);\n  set_player_ship_state(updated_ship_state);\n  return state_hash;\n}\n\nexport pure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): IntermediateShotResult {\n  // Find the Target: Check if the shot hits any part of a ship.\n  // Update the Ship State: If the shot hits, mark that part of the ship as \"damaged.\" with coordinate set to { 0, 0 }\n  // Check for Ship Sunk: If all parts of the ship are damaged, it's sunk; if no part is hit, it's a miss; otherwise, it's a hit.\n  // Return the Result: Report whether the shot was a miss, a hit, or if a ship was sunk.\n  const updated_ship_state = ShipState {\n    s11: update_hit_cell(ship_state.s11, shot_attempt),\n    s12: update_hit_cell(ship_state.s12, shot_attempt),\n    s13: update_hit_cell(ship_state.s13, shot_attempt),\n    s14: update_hit_cell(ship_state.s14, shot_attempt),\n    s21: update_hit_cell_state<2>(ship_state.s21, shot_attempt),\n    s22: update_hit_cell_state<2>(ship_state.s22, shot_attempt),\n    s23: update_hit_cell_state<2>(ship_state.s23, shot_attempt),\n    s31: update_hit_cell_state<3>(ship_state.s31, shot_attempt),\n    s32: update_hit_cell_state<3>(ship_state.s32, shot_attempt),\n    s41: update_hit_cell_state<4>(ship_state.s41, shot_attempt)\n  };\n  return IntermediateShotResult {\n    disclose(calculate_shot_result(shot_attempt, ship_state, updated_ship_state, ships, player)),\n    updated_ship_state\n  };\n}\n\npure circuit calculate_shot_result(\n  shot_attempt: Coord,\n  ship_state: ShipState,\n  updated_ship_state: ShipState,\n  ships: Ships,\n  player: Bytes<32>\n): ShotResult {\n  if (contains<2, Coord>(ship_state.s21, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s21, ship_cell: ships.s21, ship_v: ships.v21 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s21, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s22, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s22, ship_cell: ships.s22, ship_v: ships.v22 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s22, player, ship_def);\n  } else if (contains<2, Coord>(ship_state.s23, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s23, ship_cell: ships.s23, ship_v: ships.v23 };\n    return get_shot_result<2>(shot_attempt, updated_ship_state.s23, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s31, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s31, ship_cell: ships.s31, ship_v: ships.v31 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s31, player, ship_def);\n  } else if (contains<3, Coord>(ship_state.s32, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s32, ship_cell: ships.s32, ship_v: ships.v32 };\n    return get_shot_result<3>(shot_attempt, updated_ship_state.s32, player, ship_def);\n  } else if (contains<4, Coord>(ship_state.s41, shot_attempt)) {\n    const ship_def = ShipDef { ship: SHIP.s41, ship_cell: ships.s41, ship_v: ships.v41 };\n    return get_shot_result<4>(shot_attempt, updated_ship_state.s41, player, ship_def);\n  } else {\n    return ShotResult {\n      cell: shot_attempt,\n      result: SHOT_RESULT.miss,\n      player: player,\n      ship_def: unknown_ship_def()\n    };\n  }\n}\n\npure circuit assert_no_adjacent_ship(cell: Coord, ship: Coord): [] {\n    assert (cell == ship) == false \"Ships can't be adjacent\";\n}\n\npure circuit assert_neighbour_is_not_1ship(neighbours: Vector<8, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_2ship(neighbours: Vector<10, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_3ship(neighbours: Vector<12, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_4ship(neighbours: Vector<14, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_no_adjacent_neighbour_for_5ship(neighbours: Vector<16, Coord>, coords: Vector<20, Coord>): [] {\n  for (const neighbour of neighbours) {\n    assert_neighbour_is_not_ship(neighbour, coords);\n  }\n}\n\npure circuit assert_neighbour_is_not_ship(neighbour: Coord, coords: Vector<20, Coord>): [] {\n  for (const coord of coords) {\n    assert_no_adjacent_ship(neighbour, coord);\n  }\n}\n\npure circuit neighbour1_cells(cell: Coord): Vector<8, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1 },\n       Coord { x: cell.x - 1, y: cell.y },\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x, y: cell.y - 1 },\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4> },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1 },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y },\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4> }\n    ];\n}\n\n\npure circuit neighbour2_cells(cell: Coord, vertical: Boolean): Vector<10, Coord> {\n  if (vertical) {\n    return vertical_neighbour2_cells(cell);\n  } else {\n    return horizontal_neighbour2_cells(cell);\n  }\n}\n\npure circuit neighbour3_cells(cell: Coord, vertical: Boolean): Vector<12, Coord> {\n  if (vertical) {\n    return vertical_neighbour3_cells(cell);\n  } else {\n    return horizontal_neighbour3_cells(cell);\n  }\n}\n\npure circuit neighbour4_cells(cell: Coord, vertical: Boolean): Vector<14, Coord> {\n  if (vertical) {\n    return vertical_neighbour4_cells(cell);\n  } else {\n    return horizontal_neighbour4_cells(cell);\n  }\n}\n\npure circuit neighbour5_cells(cell: Coord, vertical: Boolean): Vector<16, Coord> {\n  if (vertical) {\n    return vertical_neighbour5_cells(cell);\n  } else {\n    return horizontal_neighbour5_cells(cell);\n  }\n}\n\npure circuit horizontal_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour2_cells(cell: Coord): Vector<10, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour3_cells(cell: Coord): Vector<12, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour4_cells(cell: Coord): Vector<14, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>}\n    ];\n}\n\npure circuit horizontal_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n      Coord { x: cell.x - 1, y: cell.y - 1},\n      Coord { x: cell.x - 1, y: cell.y},\n      Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x, y: cell.y - 1},\n      Coord { x: cell.x, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 2 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 3 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 4 as Uint<4>, y: cell.y + 1 as Uint<4>},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y - 1},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y},\n      Coord { x: cell.x + 5 as Uint<4>, y: cell.y + 1 as Uint<4>}\n    ];\n}\n\npure circuit vertical_neighbour5_cells(cell: Coord): Vector<16, Coord> {\n    return [\n       Coord { x: cell.x - 1, y: cell.y - 1},\n       Coord { x: cell.x - 1, y: cell.y},\n       Coord { x: cell.x - 1, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x - 1, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x, y: cell.y - 1},\n       Coord { x: cell.x, y: cell.y + 5 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y - 1},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 1 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 2 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 3 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 4 as Uint<4>},\n       Coord { x: cell.x + 1 as Uint<4>, y: cell.y + 5 as Uint<4>}\n    ];\n}\n"}
{"source_contract": "GameCommons.compact", "source_filename": "GameCommons.compact_incomplete_0", "code": "pragma language_version >= 0.13.0;\n\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 4) as Uint<4> }];\n    } else {\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 4) as Uint<4> }];\n    } else {\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173531.compact line 15, char 5:\n  parse error: found \"cell\" looking for a program element, end of file, or \";\"\n", "error_messages": ["parse error: found \"cell\" looking for a program element, end of file, or \";\""], "warning_messages": [], "compilation_time_ms": 415.54400000000004, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173531.compact", "timestamp": "2025-06-05T17:35:31.158164"}, "error_messages": ["parse error: found \"cell\" looking for a program element, end of file, or \";\""], "warning_messages": [], "mutation_type": "incomplete_variation_0", "instruction": "Complete this Compact smart contract", "expected_output": "pragma language_version >= 0.13.0;\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 4) as Uint<4> }];\n    } else {\n      assert cell.x < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n\n}\n"}
{"source_contract": "GameCommons.compact", "source_filename": "GameCommons.compact_incomplete_1", "code": "pragma language_version >= 0.13.0;\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_v: false\n    };\n  }\n\n    return fold((acc, item) => (acc || item == value), false, vector);\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n  }\n\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n    } else {\n      assert cell.x < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_v: false\n    };\n  }\n\n    return fold((acc, item) => (acc || item == value), false, vector);\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n  }\n\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n    } else {\n      assert cell.x < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173531.compact line 27, char 5:\n  parse error: found \"return\" looking for a program element or \"}\"\n", "error_messages": ["parse error: found \"return\" looking for a program element or \"}\""], "warning_messages": [], "compilation_time_ms": 416.286, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173531.compact", "timestamp": "2025-06-05T17:35:31.573987"}, "error_messages": ["parse error: found \"return\" looking for a program element or \"}\""], "warning_messages": [], "mutation_type": "incomplete_variation_1", "instruction": "Complete this Compact smart contract", "expected_output": "pragma language_version >= 0.13.0;\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 4) as Uint<4> }];\n    } else {\n      assert cell.x < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n\n}\n"}
{"source_contract": "GameCommons.compact", "source_filename": "GameCommons.compact_incomplete_2", "code": "pragma language_version >= 0.13.0;\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173531.compact line 95, char 1:\n  parse error: found end of file looking for a program element or \"}\"\n", "error_messages": ["parse error: found end of file looking for a program element or \"}\""], "warning_messages": [], "compilation_time_ms": 428.317, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173531.compact", "timestamp": "2025-06-05T17:35:31.990556"}, "error_messages": ["parse error: found end of file looking for a program element or \"}\""], "warning_messages": [], "mutation_type": "incomplete_variation_2", "instruction": "Complete this Compact smart contract", "expected_output": "pragma language_version >= 0.13.0;\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 4) as Uint<4> }];\n    } else {\n      assert cell.x < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n\n}\n"}
{"source_contract": "GameCommons.compact", "source_filename": "GameCommons.compact_incomplete_3", "code": "pragma language_version >= 0.13.0;\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173532.compact line 109, char 119:\n  parse error: found end of file looking for a statement or \"}\"\n", "error_messages": ["parse error: found end of file looking for a statement or \"}\""], "warning_messages": [], "compilation_time_ms": 464.279, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173532.compact", "timestamp": "2025-06-05T17:35:32.419163"}, "error_messages": ["parse error: found end of file looking for a statement or \"}\""], "warning_messages": [], "mutation_type": "incomplete_variation_3", "instruction": "Complete this Compact smart contract", "expected_output": "pragma language_version >= 0.13.0;\n\nmodule GameCommons {\n  import CompactStandardLibrary;\n\n  export enum GAME_STATE { waiting_p1, waiting_p2, p1_turn, p2_turn, p1_wins, p2_wins }\n  export enum SHOT_RESULT { miss, ship_hit, ship_sunk }\n  export enum SHIP { s11, s12, s13, s14, s21, s22, s23, s31, s32, s41, s51, unknown }\n\n  export struct ShipDef {\n    ship: SHIP;\n    ship_cell: Coord;\n    ship_v: Boolean;\n  }\n\n  export struct ShotResult {\n    cell: Coord;\n    result: SHOT_RESULT;\n    player: Bytes<32>;\n    ship_def: ShipDef;\n  }\n\n  export struct Coord {\n    x: Uint<4>;\n    y: Uint<4>;\n  }\n\n  export pure circuit unknown_ship_def(): ShipDef {\n    return ShipDef {\n      ship: SHIP.unknown,\n      ship_cell: Coord { 0, 0 },\n      ship_v: false\n    };\n  }\n\n  export pure circuit contains<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc || item == value), false, vector);\n  }\n\n  export pure circuit for_all_equals<#S, T>(vector: Vector<S, T>, value: T): Boolean {\n    return fold((acc, item) => (acc && item == value), true, vector);\n  }\n\n  export pure circuit update_hit_cell(ship_state: Coord, shot_attempt: Coord): Coord {\n    if (shot_attempt == ship_state) {\n      return Coord { 0, 0 };\n    } else {\n      return ship_state;\n    }\n  }\n\n  export pure circuit update_hit_cell_state<#S>(vector: Vector<S, Coord>, shot_attempt: Coord): Vector<S, Coord> {\n    return map((coord: Coord) => {\n      return update_hit_cell(coord, shot_attempt);\n   }, vector);\n  }\n\n  export pure circuit get_shot_result<#S>(\n    shot_attempt: Coord,\n    updated_ship_state_vector: Vector<S, Coord>,\n    player: Bytes<32>,\n    ship_def: ShipDef\n  ): ShotResult {\n    if (for_all_equals<S, Coord>(updated_ship_state_vector, Coord { 0, 0 })) {\n      return ship_sunk(shot_attempt, player, ship_def);\n    } else {\n      return ship_hit(shot_attempt, player);\n    }\n  }\n\n  export pure circuit ship_sunk(shot_attempt: Coord, player: Bytes<32>, ship_def: ShipDef): ShotResult {\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_sunk, player: player, ship_def: ship_def\n    };\n  }\n\n\n  export pure circuit ship_hit(shot_attempt: Coord, player: Bytes<32>): ShotResult {\n    const empty_coord: Coord = Coord { 0, 0 };\n    return ShotResult {\n      cell: shot_attempt, result: SHOT_RESULT.ship_hit, player: player, ship_def: unknown_ship_def()\n    };\n  }\n\n  export pure circuit public_key(sk: Bytes<32>): Bytes<32> {\n    return persistent_hash<Vector<2, Bytes<32>>>([pad(32, \"battleship:pk:\"), sk]);\n  }\n\n  export pure circuit assert_valid_coordinate(cell: Coord): [] {\n    assert cell.x != 0 \"Ship is out of the board\";\n    assert cell.x < 11 \"Ship is out of the board\";\n    assert cell.y != 0 \"Ship is out of the board\";\n    assert cell.y < 11 \"Ship is out of the board\";\n  }\n\n  export pure circuit ship2_cells(cell: Coord, vertical: Boolean): Vector<2, Coord> {\n    if (vertical) {\n      assert cell.y < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }];\n    } else {\n      assert cell.x < 10 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship3_cells(cell: Coord, vertical: Boolean): Vector<3, Coord> {\n    if (vertical) {\n      assert cell.y < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }];\n    } else {\n      assert cell.x < 9 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship4_cells(cell: Coord, vertical: Boolean): Vector<4, Coord> {\n    if (vertical) {\n      assert cell.y < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }];\n    } else {\n      assert cell.x < 8 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }];\n    }\n  }\n\n  export pure circuit ship5_cells(cell: Coord, vertical: Boolean): Vector<5, Coord> {\n    if (vertical) {\n      assert cell.y < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: cell.x, y: (cell.y + 1) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 2) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 3) as Uint<4> }, Coord { x: cell.x, y: (cell.y + 4) as Uint<4> }];\n    } else {\n      assert cell.x < 7 \"Ship must fit on the board\";\n      return [cell, Coord { x: (cell.x + 1) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 2) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 3) as Uint<4>, y: cell.y }, Coord { x: (cell.x + 4) as Uint<4>, y: cell.y }];\n    }\n  }\n\n}\n"}
{"source_contract": "token.compact", "source_filename": "token.compact_incomplete_0", "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  nonce = newNonce;\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  nonce = newNonce;\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173532.compact line 15, char 3:\n  parse error: found \"counter\" looking for a program element, end of file, or \";\"\n", "error_messages": ["parse error: found \"counter\" looking for a program element, end of file, or \";\""], "warning_messages": [], "compilation_time_ms": 417.954, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173532.compact", "timestamp": "2025-06-05T17:35:32.883794"}, "error_messages": ["parse error: found \"counter\" looking for a program element, end of file, or \";\""], "warning_messages": [], "mutation_type": "incomplete_variation_0", "instruction": "Complete this Compact smart contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n"}
{"source_contract": "token.compact", "source_filename": "token.compact_incomplete_1", "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nexport { CoinInfo };\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\nexport { CoinInfo };\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173533.compact line 12, char 3:\n  parse error: found \"counter\" looking for a program element, end of file, or \";\"\n", "error_messages": ["parse error: found \"counter\" looking for a program element, end of file, or \";\""], "warning_messages": [], "compilation_time_ms": 416.754, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173533.compact", "timestamp": "2025-06-05T17:35:33.302026"}, "error_messages": ["parse error: found \"counter\" looking for a program element, end of file, or \";\""], "warning_messages": [], "mutation_type": "incomplete_variation_1", "instruction": "Complete this Compact smart contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n"}
{"source_contract": "token.compact", "source_filename": "token.compact_incomplete_2", "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173533.compact line 16, char 24:\n  parse error: found end of file looking for a statement or \"}\"\n", "error_messages": ["parse error: found end of file looking for a statement or \"}\""], "warning_messages": [], "compilation_time_ms": 461.46, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173533.compact", "timestamp": "2025-06-05T17:35:33.719071"}, "error_messages": ["parse error: found end of file looking for a statement or \"}\""], "warning_messages": [], "mutation_type": "incomplete_variation_2", "instruction": "Complete this Compact smart contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n"}
{"source_contract": "token.compact", "source_filename": "token.compact_incomplete_3", "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;", "is_valid": false, "compilation_result": {"success": false, "code": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;", "stdout": "Compactc version: 0.22.0\n", "stderr": "Exception: /var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173534.compact line 18, char 23:\n  parse error: found end of file looking for a statement or \"}\"\n", "error_messages": ["parse error: found end of file looking for a statement or \"}\""], "warning_messages": [], "compilation_time_ms": 424.405, "file_path": "/var/folders/qr/7t1k9dm13mj4bqd_ykv2ljbh0000gn/T/compact_compiler_sp3yn5ut/temp_contract_20250605_173534.compact", "timestamp": "2025-06-05T17:35:34.180864"}, "error_messages": ["parse error: found end of file looking for a statement or \"}\""], "warning_messages": [], "mutation_type": "incomplete_variation_3", "instruction": "Complete this Compact smart contract", "expected_output": "pragma language_version >= 0.13.0;\n\nimport CompactStandardLibrary;\n\nexport { CoinInfo };\n\nexport ledger counter: Counter;\nexport ledger nonce: Bytes<32>;\nexport ledger tvl: Uint<64>;\n\nconstructor(initNonce: Bytes<32>) {\n  nonce = initNonce;\n}\n\nexport circuit mint(): [] {\n  counter.increment(1);\n  const newNonce = evolve_nonce(counter, nonce);\n  const amount = 1000;\n  tvl = tvl + amount as Uint<64>;\n  mint_token(pad(32, \"brick_towers_coin\"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));\n  nonce = newNonce;\n}\n"}
{"source_contract": "identity.compact", "source_filename": "instruction_example", "code": "", "is_valid": true, "compilation_result": {}, "error_messages": [], "warning_messages": [], "mutation_type": "instruction_following", "instruction": "Create a simple Compact contract with a counter", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\nexport { CoinInfo }\nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { subject_hash }\nexport { Signature }\nexport { CredentialSubject }\nexport { SignedCredentialSubject }\n"}
{"source_contract": "identity.compact", "source_filename": "instruction_example", "code": "", "is_valid": true, "compilation_result": {}, "error_messages": [], "warning_messages": [], "mutation_type": "instruction_following", "instruction": "Write a Compact contract that manages a ledger balance", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\nexport { CoinInfo }\nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { subject_hash }\nexport { Signature }\nexport { CredentialSubject }\nexport { SignedCredentialSubject }\n"}
{"source_contract": "identity.compact", "source_filename": "instruction_example", "code": "", "is_valid": true, "compilation_result": {}, "error_messages": [], "warning_messages": [], "mutation_type": "instruction_following", "instruction": "Implement a Compact contract with basic token functionality", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\nexport { CoinInfo }\nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { subject_hash }\nexport { Signature }\nexport { CredentialSubject }\nexport { SignedCredentialSubject }\n"}
{"source_contract": "identity.compact", "source_filename": "instruction_example", "code": "", "is_valid": true, "compilation_result": {}, "error_messages": [], "warning_messages": [], "mutation_type": "instruction_following", "instruction": "Design a Compact contract with multiple circuits", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\nexport { CoinInfo }\nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { subject_hash }\nexport { Signature }\nexport { CredentialSubject }\nexport { SignedCredentialSubject }\n"}
{"source_contract": "identity.compact", "source_filename": "instruction_example", "code": "", "is_valid": true, "compilation_result": {}, "error_messages": [], "warning_messages": [], "mutation_type": "instruction_following", "instruction": "Create a Compact contract with proper error handling", "expected_output": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nimport \"../../crypto/Crypto\";\nexport { CoinInfo }\nexport { sign }\nexport { verify_signature }\nexport { derive_pk }\nexport { subject_hash }\nexport { Signature }\nexport { CredentialSubject }\nexport { SignedCredentialSubject }\n"}

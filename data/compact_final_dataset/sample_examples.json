[
  {
    "text": "pragma language_version >= 0.14.0;\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Left-hand side: s * B\n    const lhs: CurvePoint = ec_mul_generator(s);\n\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n  }\n}"
  },
  {
    "text": "pragma language_version >= 0.14.0;\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Left-hand side: s * B\n    const lhs: CurvePoint = ec_mul_generator(s);\n\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n  }\n}\n"
  },
  {
    "text": "pragma language_version >= 0.14.0;\n\nmodule Crypto {\n  import CompactStandardLibrary;\n\n  circuit point_to_bytes(p: CurvePoint): Bytes<32> {\n    return persistent_hash<CurvePoint>(p);\n  }\n\n  struct Bytes96 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n    b2: Bytes<32>;\n  }\n\n  struct Bytes64 {\n    b0: Bytes<32>;\n    b1: Bytes<32>;\n  }\n\n  export struct Signature {\n    pk: CurvePoint;\n    R: CurvePoint;\n    s: Field;\n  }\n\n  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject\n  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently\n  export struct CredentialSubject {\n      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)\n      first_name: Bytes<32>; // The first name of the subject\n      last_name: Bytes<32>; // The last name of the subject\n      national_identifier: Bytes<32>; // The national identifier of the subject\n      birth_timestamp: Uint<64>; // The birth timestamp of the subject\n  }\n\n  export struct SignedCredentialSubject {\n    subject: CredentialSubject;\n    signature: Signature;\n  }\n\n  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {\n    return persistent_hash<CredentialSubject>(credentialSubject);\n  }\n\n  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {\n     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);\n     const pk: CurvePoint = ec_mul_generator(sk);\n     return pk;\n  }\n\n  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {\n    // Convert sk_bytes to Field\n    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);\n    // Compute public key: pk = sk * B\n    const pk: CurvePoint = ec_mul_generator(sk);\n\n    // Derive nonce k deterministically: k = H(sk_bytes || msg)\n    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };\n    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar\n\n    // Compute R = k * B\n    const R: CurvePoint = ec_mul_generator(k);\n\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Compute signature: s = k + c * sk\n    const s: Field = k + (c * sk);\n\n    return Signature { pk: pk, R: R, s: s };\n  }\n\n  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {\n    const {pk, R, s} = signature;\n    // Compute challenge: c = H(R || pk || msg)\n    const R_bytes: Bytes<32> = point_to_bytes(R);\n    const pk_bytes: Bytes<32> = point_to_bytes(pk);\n    const c_bytes: Bytes96 = Bytes96 {\n      b0: R_bytes,\n      b1: pk_bytes,\n      b2: msg\n    };\n    const c: Field = transient_hash<Bytes96>(c_bytes);\n\n    // Left-hand side: s * B\n    const lhs: CurvePoint = ec_mul_generator(s);\n\n    // Right-hand side: R + c * pk\n    const c_pk: CurvePoint = ec_mul(pk, c);\n    const rhs: CurvePoint = ec_add(R, c_pk);\n\n    // Enforce verification equation\n    assert lhs == rhs \"Signature verification failed\";\n  }\n}\n"
  },
  {
    "text": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nexport { CurvePoint }\n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {\n  wallet_public_key = own_public_key();\n  signing_public_key = signing_key;\n}"
  },
  {
    "text": "pragma language_version >= 0.14.0;\n\nimport CompactStandardLibrary;\nexport { CurvePoint }\n\nexport ledger wallet_public_key: ZswapCoinPublicKey;\nexport ledger signing_public_key: CurvePoint;\n\nexport circuit register(signing_key: CurvePoint): [] {\n  wallet_public_key = own_public_key();\n  signing_public_key = signing_key;\n}\n"
  }
]